/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * Leaflet.markercluster 1.5.3+master.e5124b2,\n * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n * https://github.com/Leaflet/Leaflet.markercluster\n * (c) 2012-2017, Dave Leaver, smartrak\n */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /*\n\t * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n\t */ var MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({\n        options: {\n            maxClusterRadius: 80,\n            iconCreateFunction: null,\n            clusterPane: L.Marker.prototype.options.pane,\n            spiderfyOnEveryZoom: false,\n            spiderfyOnMaxZoom: true,\n            showCoverageOnHover: true,\n            zoomToBoundsOnClick: true,\n            singleMarkerMode: false,\n            disableClusteringAtZoom: null,\n            // Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n            // is the default behaviour for performance reasons.\n            removeOutsideVisibleBounds: true,\n            // Set to false to disable all animations (zoom and spiderfy).\n            // If false, option animateAddingMarkers below has no effect.\n            // If L.DomUtil.TRANSITION is falsy, this option has no effect.\n            animate: true,\n            //Whether to animate adding markers after adding the MarkerClusterGroup to the map\n            // If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n            animateAddingMarkers: false,\n            // Make it possible to provide custom function to calculate spiderfy shape positions\n            spiderfyShapePositions: null,\n            //Increase to increase the distance away that spiderfied markers appear from the center\n            spiderfyDistanceMultiplier: 1,\n            // Make it possible to specify a polyline options on a spider leg\n            spiderLegPolylineOptions: {\n                weight: 1.5,\n                color: \"#222\",\n                opacity: 0.5\n            },\n            // When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts\n            chunkedLoading: false,\n            chunkInterval: 200,\n            chunkDelay: 50,\n            chunkProgress: null,\n            //Options to pass to the L.Polygon constructor\n            polygonOptions: {}\n        },\n        initialize: function(options) {\n            L.Util.setOptions(this, options);\n            if (!this.options.iconCreateFunction) {\n                this.options.iconCreateFunction = this._defaultIconCreateFunction;\n            }\n            this._featureGroup = L.featureGroup();\n            this._featureGroup.addEventParent(this);\n            this._nonPointGroup = L.featureGroup();\n            this._nonPointGroup.addEventParent(this);\n            this._inZoomAnimation = 0;\n            this._needsClustering = [];\n            this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\n            //The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n            this._currentShownBounds = null;\n            this._queue = [];\n            this._childMarkerEventHandlers = {\n                \"dragstart\": this._childMarkerDragStart,\n                \"move\": this._childMarkerMoved,\n                \"dragend\": this._childMarkerDragEnd\n            };\n            // Hook the appropriate animation methods.\n            var animate = L.DomUtil.TRANSITION && this.options.animate;\n            L.extend(this, animate ? this._withAnimation : this._noAnimation);\n            // Remember which MarkerCluster class to instantiate (animated or not).\n            this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\n        },\n        addLayer: function(layer) {\n            if (layer instanceof L.LayerGroup) {\n                return this.addLayers([\n                    layer\n                ]);\n            }\n            //Don't cluster non point data\n            if (!layer.getLatLng) {\n                this._nonPointGroup.addLayer(layer);\n                this.fire(\"layeradd\", {\n                    layer: layer\n                });\n                return this;\n            }\n            if (!this._map) {\n                this._needsClustering.push(layer);\n                this.fire(\"layeradd\", {\n                    layer: layer\n                });\n                return this;\n            }\n            if (this.hasLayer(layer)) {\n                return this;\n            }\n            //If we have already clustered we'll need to add this one to a cluster\n            if (this._unspiderfy) {\n                this._unspiderfy();\n            }\n            this._addLayer(layer, this._maxZoom);\n            this.fire(\"layeradd\", {\n                layer: layer\n            });\n            // Refresh bounds and weighted positions.\n            this._topClusterLevel._recalculateBounds();\n            this._refreshClustersIcons();\n            //Work out what is visible\n            var visibleLayer = layer, currentZoom = this._zoom;\n            if (layer.__parent) {\n                while(visibleLayer.__parent._zoom >= currentZoom){\n                    visibleLayer = visibleLayer.__parent;\n                }\n            }\n            if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n                if (this.options.animateAddingMarkers) {\n                    this._animationAddLayer(layer, visibleLayer);\n                } else {\n                    this._animationAddLayerNonAnimated(layer, visibleLayer);\n                }\n            }\n            return this;\n        },\n        removeLayer: function(layer) {\n            if (layer instanceof L.LayerGroup) {\n                return this.removeLayers([\n                    layer\n                ]);\n            }\n            //Non point layers\n            if (!layer.getLatLng) {\n                this._nonPointGroup.removeLayer(layer);\n                this.fire(\"layerremove\", {\n                    layer: layer\n                });\n                return this;\n            }\n            if (!this._map) {\n                if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\n                    this._needsRemoving.push({\n                        layer: layer,\n                        latlng: layer._latlng\n                    });\n                }\n                this.fire(\"layerremove\", {\n                    layer: layer\n                });\n                return this;\n            }\n            if (!layer.__parent) {\n                return this;\n            }\n            if (this._unspiderfy) {\n                this._unspiderfy();\n                this._unspiderfyLayer(layer);\n            }\n            //Remove the marker from clusters\n            this._removeLayer(layer, true);\n            this.fire(\"layerremove\", {\n                layer: layer\n            });\n            // Refresh bounds and weighted positions.\n            this._topClusterLevel._recalculateBounds();\n            this._refreshClustersIcons();\n            layer.off(this._childMarkerEventHandlers, this);\n            if (this._featureGroup.hasLayer(layer)) {\n                this._featureGroup.removeLayer(layer);\n                if (layer.clusterShow) {\n                    layer.clusterShow();\n                }\n            }\n            return this;\n        },\n        //Takes an array of markers and adds them in bulk\n        addLayers: function(layersArray, skipLayerAddEvent) {\n            if (!L.Util.isArray(layersArray)) {\n                return this.addLayer(layersArray);\n            }\n            var fg = this._featureGroup, npg = this._nonPointGroup, chunked = this.options.chunkedLoading, chunkInterval = this.options.chunkInterval, chunkProgress = this.options.chunkProgress, l = layersArray.length, offset = 0, originalArray = true, m;\n            if (this._map) {\n                var started = new Date().getTime();\n                var process = L.bind(function() {\n                    var start = new Date().getTime();\n                    // Make sure to unspiderfy before starting to add some layers\n                    if (this._map && this._unspiderfy) {\n                        this._unspiderfy();\n                    }\n                    for(; offset < l; offset++){\n                        if (chunked && offset % 200 === 0) {\n                            // every couple hundred markers, instrument the time elapsed since processing started:\n                            var elapsed = new Date().getTime() - start;\n                            if (elapsed > chunkInterval) {\n                                break; // been working too hard, time to take a break :-)\n                            }\n                        }\n                        m = layersArray[offset];\n                        // Group of layers, append children to layersArray and skip.\n                        // Side effects:\n                        // - Total increases, so chunkProgress ratio jumps backward.\n                        // - Groups are not included in this group, only their non-group child layers (hasLayer).\n                        // Changing array length while looping does not affect performance in current browsers:\n                        // http://jsperf.com/for-loop-changing-length/6\n                        if (m instanceof L.LayerGroup) {\n                            if (originalArray) {\n                                layersArray = layersArray.slice();\n                                originalArray = false;\n                            }\n                            this._extractNonGroupLayers(m, layersArray);\n                            l = layersArray.length;\n                            continue;\n                        }\n                        //Not point data, can't be clustered\n                        if (!m.getLatLng) {\n                            npg.addLayer(m);\n                            if (!skipLayerAddEvent) {\n                                this.fire(\"layeradd\", {\n                                    layer: m\n                                });\n                            }\n                            continue;\n                        }\n                        if (this.hasLayer(m)) {\n                            continue;\n                        }\n                        this._addLayer(m, this._maxZoom);\n                        if (!skipLayerAddEvent) {\n                            this.fire(\"layeradd\", {\n                                layer: m\n                            });\n                        }\n                        //If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n                        if (m.__parent) {\n                            if (m.__parent.getChildCount() === 2) {\n                                var markers = m.__parent.getAllChildMarkers(), otherMarker = markers[0] === m ? markers[1] : markers[0];\n                                fg.removeLayer(otherMarker);\n                            }\n                        }\n                    }\n                    if (chunkProgress) {\n                        // report progress and time elapsed:\n                        chunkProgress(offset, l, new Date().getTime() - started);\n                    }\n                    // Completed processing all markers.\n                    if (offset === l) {\n                        // Refresh bounds and weighted positions.\n                        this._topClusterLevel._recalculateBounds();\n                        this._refreshClustersIcons();\n                        this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n                    } else {\n                        setTimeout(process, this.options.chunkDelay);\n                    }\n                }, this);\n                process();\n            } else {\n                var needsClustering = this._needsClustering;\n                for(; offset < l; offset++){\n                    m = layersArray[offset];\n                    // Group of layers, append children to layersArray and skip.\n                    if (m instanceof L.LayerGroup) {\n                        if (originalArray) {\n                            layersArray = layersArray.slice();\n                            originalArray = false;\n                        }\n                        this._extractNonGroupLayers(m, layersArray);\n                        l = layersArray.length;\n                        continue;\n                    }\n                    //Not point data, can't be clustered\n                    if (!m.getLatLng) {\n                        npg.addLayer(m);\n                        continue;\n                    }\n                    if (this.hasLayer(m)) {\n                        continue;\n                    }\n                    needsClustering.push(m);\n                }\n            }\n            return this;\n        },\n        //Takes an array of markers and removes them in bulk\n        removeLayers: function(layersArray) {\n            var i, m, l = layersArray.length, fg = this._featureGroup, npg = this._nonPointGroup, originalArray = true;\n            if (!this._map) {\n                for(i = 0; i < l; i++){\n                    m = layersArray[i];\n                    // Group of layers, append children to layersArray and skip.\n                    if (m instanceof L.LayerGroup) {\n                        if (originalArray) {\n                            layersArray = layersArray.slice();\n                            originalArray = false;\n                        }\n                        this._extractNonGroupLayers(m, layersArray);\n                        l = layersArray.length;\n                        continue;\n                    }\n                    this._arraySplice(this._needsClustering, m);\n                    npg.removeLayer(m);\n                    if (this.hasLayer(m)) {\n                        this._needsRemoving.push({\n                            layer: m,\n                            latlng: m._latlng\n                        });\n                    }\n                    this.fire(\"layerremove\", {\n                        layer: m\n                    });\n                }\n                return this;\n            }\n            if (this._unspiderfy) {\n                this._unspiderfy();\n                // Work on a copy of the array, so that next loop is not affected.\n                var layersArray2 = layersArray.slice(), l2 = l;\n                for(i = 0; i < l2; i++){\n                    m = layersArray2[i];\n                    // Group of layers, append children to layersArray and skip.\n                    if (m instanceof L.LayerGroup) {\n                        this._extractNonGroupLayers(m, layersArray2);\n                        l2 = layersArray2.length;\n                        continue;\n                    }\n                    this._unspiderfyLayer(m);\n                }\n            }\n            for(i = 0; i < l; i++){\n                m = layersArray[i];\n                // Group of layers, append children to layersArray and skip.\n                if (m instanceof L.LayerGroup) {\n                    if (originalArray) {\n                        layersArray = layersArray.slice();\n                        originalArray = false;\n                    }\n                    this._extractNonGroupLayers(m, layersArray);\n                    l = layersArray.length;\n                    continue;\n                }\n                if (!m.__parent) {\n                    npg.removeLayer(m);\n                    this.fire(\"layerremove\", {\n                        layer: m\n                    });\n                    continue;\n                }\n                this._removeLayer(m, true, true);\n                this.fire(\"layerremove\", {\n                    layer: m\n                });\n                if (fg.hasLayer(m)) {\n                    fg.removeLayer(m);\n                    if (m.clusterShow) {\n                        m.clusterShow();\n                    }\n                }\n            }\n            // Refresh bounds and weighted positions.\n            this._topClusterLevel._recalculateBounds();\n            this._refreshClustersIcons();\n            //Fix up the clusters and markers on the map\n            this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n            return this;\n        },\n        //Removes all layers from the MarkerClusterGroup\n        clearLayers: function() {\n            //Need our own special implementation as the LayerGroup one doesn't work for us\n            //If we aren't on the map (yet), blow away the markers we know of\n            if (!this._map) {\n                this._needsClustering = [];\n                this._needsRemoving = [];\n                delete this._gridClusters;\n                delete this._gridUnclustered;\n            }\n            if (this._noanimationUnspiderfy) {\n                this._noanimationUnspiderfy();\n            }\n            //Remove all the visible layers\n            this._featureGroup.clearLayers();\n            this._nonPointGroup.clearLayers();\n            this.eachLayer(function(marker) {\n                marker.off(this._childMarkerEventHandlers, this);\n                delete marker.__parent;\n            }, this);\n            if (this._map) {\n                //Reset _topClusterLevel and the DistanceGrids\n                this._generateInitialClusters();\n            }\n            return this;\n        },\n        //Override FeatureGroup.getBounds as it doesn't work\n        getBounds: function() {\n            var bounds = new L.LatLngBounds();\n            if (this._topClusterLevel) {\n                bounds.extend(this._topClusterLevel._bounds);\n            }\n            for(var i = this._needsClustering.length - 1; i >= 0; i--){\n                bounds.extend(this._needsClustering[i].getLatLng());\n            }\n            bounds.extend(this._nonPointGroup.getBounds());\n            return bounds;\n        },\n        //Overrides LayerGroup.eachLayer\n        eachLayer: function(method, context) {\n            var markers = this._needsClustering.slice(), needsRemoving = this._needsRemoving, thisNeedsRemoving, i, j;\n            if (this._topClusterLevel) {\n                this._topClusterLevel.getAllChildMarkers(markers);\n            }\n            for(i = markers.length - 1; i >= 0; i--){\n                thisNeedsRemoving = true;\n                for(j = needsRemoving.length - 1; j >= 0; j--){\n                    if (needsRemoving[j].layer === markers[i]) {\n                        thisNeedsRemoving = false;\n                        break;\n                    }\n                }\n                if (thisNeedsRemoving) {\n                    method.call(context, markers[i]);\n                }\n            }\n            this._nonPointGroup.eachLayer(method, context);\n        },\n        //Overrides LayerGroup.getLayers\n        getLayers: function() {\n            var layers = [];\n            this.eachLayer(function(l) {\n                layers.push(l);\n            });\n            return layers;\n        },\n        //Overrides LayerGroup.getLayer, WARNING: Really bad performance\n        getLayer: function(id) {\n            var result = null;\n            id = parseInt(id, 10);\n            this.eachLayer(function(l) {\n                if (L.stamp(l) === id) {\n                    result = l;\n                }\n            });\n            return result;\n        },\n        //Returns true if the given layer is in this MarkerClusterGroup\n        hasLayer: function(layer) {\n            if (!layer) {\n                return false;\n            }\n            var i, anArray = this._needsClustering;\n            for(i = anArray.length - 1; i >= 0; i--){\n                if (anArray[i] === layer) {\n                    return true;\n                }\n            }\n            anArray = this._needsRemoving;\n            for(i = anArray.length - 1; i >= 0; i--){\n                if (anArray[i].layer === layer) {\n                    return false;\n                }\n            }\n            return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\n        },\n        //Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n        zoomToShowLayer: function(layer, callback) {\n            var map = this._map;\n            if (typeof callback !== \"function\") {\n                callback = function() {};\n            }\n            var showMarker = function() {\n                // Assumes that map.hasLayer checks for direct appearance on map, not recursively calling\n                // hasLayer on Layer Groups that are on map (typically not calling this MarkerClusterGroup.hasLayer, which would always return true)\n                if ((map.hasLayer(layer) || map.hasLayer(layer.__parent)) && !this._inZoomAnimation) {\n                    this._map.off(\"moveend\", showMarker, this);\n                    this.off(\"animationend\", showMarker, this);\n                    if (map.hasLayer(layer)) {\n                        callback();\n                    } else if (layer.__parent._icon) {\n                        this.once(\"spiderfied\", callback, this);\n                        layer.__parent.spiderfy();\n                    }\n                }\n            };\n            if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\n                //Layer is visible ond on screen, immediate return\n                callback();\n            } else if (layer.__parent._zoom < Math.round(this._map._zoom)) {\n                //Layer should be visible at this zoom level. It must not be on screen so just pan over to it\n                this._map.on(\"moveend\", showMarker, this);\n                this._map.panTo(layer.getLatLng());\n            } else {\n                this._map.on(\"moveend\", showMarker, this);\n                this.on(\"animationend\", showMarker, this);\n                layer.__parent.zoomToBounds();\n            }\n        },\n        //Overrides FeatureGroup.onAdd\n        onAdd: function(map) {\n            this._map = map;\n            var i, l, layer;\n            if (!isFinite(this._map.getMaxZoom())) {\n                throw \"Map has no maxZoom specified\";\n            }\n            this._featureGroup.addTo(map);\n            this._nonPointGroup.addTo(map);\n            if (!this._gridClusters) {\n                this._generateInitialClusters();\n            }\n            this._maxLat = map.options.crs.projection.MAX_LATITUDE;\n            //Restore all the positions as they are in the MCG before removing them\n            for(i = 0, l = this._needsRemoving.length; i < l; i++){\n                layer = this._needsRemoving[i];\n                layer.newlatlng = layer.layer._latlng;\n                layer.layer._latlng = layer.latlng;\n            }\n            //Remove them, then restore their new positions\n            for(i = 0, l = this._needsRemoving.length; i < l; i++){\n                layer = this._needsRemoving[i];\n                this._removeLayer(layer.layer, true);\n                layer.layer._latlng = layer.newlatlng;\n            }\n            this._needsRemoving = [];\n            //Remember the current zoom level and bounds\n            this._zoom = Math.round(this._map._zoom);\n            this._currentShownBounds = this._getExpandedVisibleBounds();\n            this._map.on(\"zoomend\", this._zoomEnd, this);\n            this._map.on(\"moveend\", this._moveEnd, this);\n            if (this._spiderfierOnAdd) {\n                this._spiderfierOnAdd();\n            }\n            this._bindEvents();\n            //Actually add our markers to the map:\n            l = this._needsClustering;\n            this._needsClustering = [];\n            this.addLayers(l, true);\n        },\n        //Overrides FeatureGroup.onRemove\n        onRemove: function(map) {\n            map.off(\"zoomend\", this._zoomEnd, this);\n            map.off(\"moveend\", this._moveEnd, this);\n            this._unbindEvents();\n            //In case we are in a cluster animation\n            this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\");\n            if (this._spiderfierOnRemove) {\n                this._spiderfierOnRemove();\n            }\n            delete this._maxLat;\n            //Clean up all the layers we added to the map\n            this._hideCoverage();\n            this._featureGroup.remove();\n            this._nonPointGroup.remove();\n            this._featureGroup.clearLayers();\n            this._map = null;\n        },\n        getVisibleParent: function(marker) {\n            var vMarker = marker;\n            while(vMarker && !vMarker._icon){\n                vMarker = vMarker.__parent;\n            }\n            return vMarker || null;\n        },\n        //Remove the given object from the given array\n        _arraySplice: function(anArray, obj) {\n            for(var i = anArray.length - 1; i >= 0; i--){\n                if (anArray[i] === obj) {\n                    anArray.splice(i, 1);\n                    return true;\n                }\n            }\n        },\n        /**\n\t\t * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.\n\t\t * @param marker to be removed from _gridUnclustered.\n\t\t * @param z integer bottom start zoom level (included)\n\t\t * @private\n\t\t */ _removeFromGridUnclustered: function(marker, z) {\n            var map = this._map, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom());\n            for(; z >= minZoom; z--){\n                if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n                    break;\n                }\n            }\n        },\n        _childMarkerDragStart: function(e) {\n            e.target.__dragStart = e.target._latlng;\n        },\n        _childMarkerMoved: function(e) {\n            if (!this._ignoreMove && !e.target.__dragStart) {\n                var isPopupOpen = e.target._popup && e.target._popup.isOpen();\n                this._moveChild(e.target, e.oldLatLng, e.latlng);\n                if (isPopupOpen) {\n                    e.target.openPopup();\n                }\n            }\n        },\n        _moveChild: function(layer, from, to) {\n            layer._latlng = from;\n            this.removeLayer(layer);\n            layer._latlng = to;\n            this.addLayer(layer);\n        },\n        _childMarkerDragEnd: function(e) {\n            var dragStart = e.target.__dragStart;\n            delete e.target.__dragStart;\n            if (dragStart) {\n                this._moveChild(e.target, dragStart, e.target._latlng);\n            }\n        },\n        //Internal function for removing a marker from everything.\n        //dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n        _removeLayer: function(marker, removeFromDistanceGrid, dontUpdateMap) {\n            var gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, fg = this._featureGroup, map = this._map, minZoom = Math.floor(this._map.getMinZoom());\n            //Remove the marker from distance clusters it might be in\n            if (removeFromDistanceGrid) {\n                this._removeFromGridUnclustered(marker, this._maxZoom);\n            }\n            //Work our way up the clusters removing them as we go if required\n            var cluster = marker.__parent, markers = cluster._markers, otherMarker;\n            //Remove the marker from the immediate parents marker list\n            this._arraySplice(markers, marker);\n            while(cluster){\n                cluster._childCount--;\n                cluster._boundsNeedUpdate = true;\n                if (cluster._zoom < minZoom) {\n                    break;\n                } else if (removeFromDistanceGrid && cluster._childCount <= 1) {\n                    //We need to push the other marker up to the parent\n                    otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n                    //Update distance grid\n                    gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n                    gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n                    //Move otherMarker up to parent\n                    this._arraySplice(cluster.__parent._childClusters, cluster);\n                    cluster.__parent._markers.push(otherMarker);\n                    otherMarker.__parent = cluster.__parent;\n                    if (cluster._icon) {\n                        //Cluster is currently on the map, need to put the marker on the map instead\n                        fg.removeLayer(cluster);\n                        if (!dontUpdateMap) {\n                            fg.addLayer(otherMarker);\n                        }\n                    }\n                } else {\n                    cluster._iconNeedsUpdate = true;\n                }\n                cluster = cluster.__parent;\n            }\n            delete marker.__parent;\n        },\n        _isOrIsParent: function(el, oel) {\n            while(oel){\n                if (el === oel) {\n                    return true;\n                }\n                oel = oel.parentNode;\n            }\n            return false;\n        },\n        //Override L.Evented.fire\n        fire: function(type, data, propagate) {\n            if (data && data.layer instanceof L.MarkerCluster) {\n                //Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\n                if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {\n                    return;\n                }\n                type = \"cluster\" + type;\n            }\n            L.FeatureGroup.prototype.fire.call(this, type, data, propagate);\n        },\n        //Override L.Evented.listens\n        listens: function(type, propagate) {\n            return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, \"cluster\" + type, propagate);\n        },\n        //Default functionality\n        _defaultIconCreateFunction: function(cluster) {\n            var childCount = cluster.getChildCount();\n            var c = \" marker-cluster-\";\n            if (childCount < 10) {\n                c += \"small\";\n            } else if (childCount < 100) {\n                c += \"medium\";\n            } else {\n                c += \"large\";\n            }\n            return new L.DivIcon({\n                html: \"<div><span>\" + childCount + \"</span></div>\",\n                className: \"marker-cluster\" + c,\n                iconSize: new L.Point(40, 40)\n            });\n        },\n        _bindEvents: function() {\n            var map = this._map, spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom;\n            //Zoom on cluster click or spiderfy if we are at the lowest level\n            if (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n                this.on(\"clusterclick clusterkeypress\", this._zoomOrSpiderfy, this);\n            }\n            //Show convex hull (boundary) polygon on mouse over\n            if (showCoverageOnHover) {\n                this.on(\"clustermouseover\", this._showCoverage, this);\n                this.on(\"clustermouseout\", this._hideCoverage, this);\n                map.on(\"zoomend\", this._hideCoverage, this);\n            }\n        },\n        _zoomOrSpiderfy: function(e) {\n            var cluster = e.layer, bottomCluster = cluster;\n            if (e.type === \"clusterkeypress\" && e.originalEvent && e.originalEvent.keyCode !== 13) {\n                return;\n            }\n            while(bottomCluster._childClusters.length === 1){\n                bottomCluster = bottomCluster._childClusters[0];\n            }\n            if (bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount && this.options.spiderfyOnMaxZoom) {\n                // All child markers are contained in a single cluster from this._maxZoom to this cluster.\n                cluster.spiderfy();\n            } else if (this.options.zoomToBoundsOnClick) {\n                cluster.zoomToBounds();\n            }\n            if (this.options.spiderfyOnEveryZoom) {\n                cluster.spiderfy();\n            }\n            // Focus the map again for keyboard users.\n            if (e.originalEvent && e.originalEvent.keyCode === 13) {\n                this._map._container.focus();\n            }\n        },\n        _showCoverage: function(e) {\n            var map = this._map;\n            if (this._inZoomAnimation) {\n                return;\n            }\n            if (this._shownPolygon) {\n                map.removeLayer(this._shownPolygon);\n            }\n            if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\n                this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\n                map.addLayer(this._shownPolygon);\n            }\n        },\n        _hideCoverage: function() {\n            if (this._shownPolygon) {\n                this._map.removeLayer(this._shownPolygon);\n                this._shownPolygon = null;\n            }\n        },\n        _unbindEvents: function() {\n            var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom, map = this._map;\n            if (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n                this.off(\"clusterclick clusterkeypress\", this._zoomOrSpiderfy, this);\n            }\n            if (showCoverageOnHover) {\n                this.off(\"clustermouseover\", this._showCoverage, this);\n                this.off(\"clustermouseout\", this._hideCoverage, this);\n                map.off(\"zoomend\", this._hideCoverage, this);\n            }\n        },\n        _zoomEnd: function() {\n            if (!this._map) {\n                return;\n            }\n            this._mergeSplitClusters();\n            this._zoom = Math.round(this._map._zoom);\n            this._currentShownBounds = this._getExpandedVisibleBounds();\n        },\n        _moveEnd: function() {\n            if (this._inZoomAnimation) {\n                return;\n            }\n            var newBounds = this._getExpandedVisibleBounds();\n            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);\n            this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);\n            this._currentShownBounds = newBounds;\n            return;\n        },\n        _generateInitialClusters: function() {\n            var maxZoom = Math.ceil(this._map.getMaxZoom()), minZoom = Math.floor(this._map.getMinZoom()), radius = this.options.maxClusterRadius, radiusFn = radius;\n            //If we just set maxClusterRadius to a single number, we need to create\n            //a simple function to return that number. Otherwise, we just have to\n            //use the function we've passed in.\n            if (typeof radius !== \"function\") {\n                radiusFn = function() {\n                    return radius;\n                };\n            }\n            if (this.options.disableClusteringAtZoom !== null) {\n                maxZoom = this.options.disableClusteringAtZoom - 1;\n            }\n            this._maxZoom = maxZoom;\n            this._gridClusters = {};\n            this._gridUnclustered = {};\n            //Set up DistanceGrids for each zoom\n            for(var zoom = maxZoom; zoom >= minZoom; zoom--){\n                this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));\n                this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));\n            }\n            // Instantiate the appropriate L.MarkerCluster class (animated or not).\n            this._topClusterLevel = new this._markerCluster(this, minZoom - 1);\n        },\n        //Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n        _addLayer: function(layer, zoom) {\n            var gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom()), markerPoint, z;\n            if (this.options.singleMarkerMode) {\n                this._overrideMarkerIcon(layer);\n            }\n            layer.on(this._childMarkerEventHandlers, this);\n            //Find the lowest zoom level to slot this one in\n            for(; zoom >= minZoom; zoom--){\n                markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n                //Try find a cluster close by\n                var closest = gridClusters[zoom].getNearObject(markerPoint);\n                if (closest) {\n                    closest._addChild(layer);\n                    layer.__parent = closest;\n                    return;\n                }\n                //Try find a marker close by to form a new cluster with\n                closest = gridUnclustered[zoom].getNearObject(markerPoint);\n                if (closest) {\n                    var parent = closest.__parent;\n                    if (parent) {\n                        this._removeLayer(closest, false);\n                    }\n                    //Create new cluster with these 2 in it\n                    var newCluster = new this._markerCluster(this, zoom, closest, layer);\n                    gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n                    closest.__parent = newCluster;\n                    layer.__parent = newCluster;\n                    //First create any new intermediate parent clusters that don't exist\n                    var lastParent = newCluster;\n                    for(z = zoom - 1; z > parent._zoom; z--){\n                        lastParent = new this._markerCluster(this, z, lastParent);\n                        gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n                    }\n                    parent._addChild(lastParent);\n                    //Remove closest from this zoom level and any above that it is in, replace with newCluster\n                    this._removeFromGridUnclustered(closest, zoom);\n                    return;\n                }\n                //Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n                gridUnclustered[zoom].addObject(layer, markerPoint);\n            }\n            //Didn't get in anything, add us to the top\n            this._topClusterLevel._addChild(layer);\n            layer.__parent = this._topClusterLevel;\n            return;\n        },\n        /**\n\t\t * Refreshes the icon of all \"dirty\" visible clusters.\n\t\t * Non-visible \"dirty\" clusters will be updated when they are added to the map.\n\t\t * @private\n\t\t */ _refreshClustersIcons: function() {\n            this._featureGroup.eachLayer(function(c) {\n                if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n                    c._updateIcon();\n                }\n            });\n        },\n        //Enqueue code to fire after the marker expand/contract has happened\n        _enqueue: function(fn) {\n            this._queue.push(fn);\n            if (!this._queueTimeout) {\n                this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\n            }\n        },\n        _processQueue: function() {\n            for(var i = 0; i < this._queue.length; i++){\n                this._queue[i].call(this);\n            }\n            this._queue.length = 0;\n            clearTimeout(this._queueTimeout);\n            this._queueTimeout = null;\n        },\n        //Merge and split any existing clusters that are too big or small\n        _mergeSplitClusters: function() {\n            var mapZoom = Math.round(this._map._zoom);\n            //In case we are starting to split before the animation finished\n            this._processQueue();\n            if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) {\n                this._animationStart();\n                //Remove clusters now off screen\n                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());\n                this._animationZoomIn(this._zoom, mapZoom);\n            } else if (this._zoom > mapZoom) {\n                this._animationStart();\n                this._animationZoomOut(this._zoom, mapZoom);\n            } else {\n                this._moveEnd();\n            }\n        },\n        //Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n        _getExpandedVisibleBounds: function() {\n            if (!this.options.removeOutsideVisibleBounds) {\n                return this._mapBoundsInfinite;\n            } else if (L.Browser.mobile) {\n                return this._checkBoundsMaxLat(this._map.getBounds());\n            }\n            return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.\n        },\n        /**\n\t\t * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude\n\t\t * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).\n\t\t * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without\n\t\t * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,\n\t\t * making the user think that MCG \"eats\" them and never displays them again.\n\t\t * @param bounds L.LatLngBounds\n\t\t * @returns {L.LatLngBounds}\n\t\t * @private\n\t\t */ _checkBoundsMaxLat: function(bounds) {\n            var maxLat = this._maxLat;\n            if (maxLat !== undefined) {\n                if (bounds.getNorth() >= maxLat) {\n                    bounds._northEast.lat = Infinity;\n                }\n                if (bounds.getSouth() <= -maxLat) {\n                    bounds._southWest.lat = -Infinity;\n                }\n            }\n            return bounds;\n        },\n        //Shared animation code\n        _animationAddLayerNonAnimated: function(layer, newCluster) {\n            if (newCluster === layer) {\n                this._featureGroup.addLayer(layer);\n            } else if (newCluster._childCount === 2) {\n                newCluster._addToMap();\n                var markers = newCluster.getAllChildMarkers();\n                this._featureGroup.removeLayer(markers[0]);\n                this._featureGroup.removeLayer(markers[1]);\n            } else {\n                newCluster._updateIcon();\n            }\n        },\n        /**\n\t\t * Extracts individual (i.e. non-group) layers from a Layer Group.\n\t\t * @param group to extract layers from.\n\t\t * @param output {Array} in which to store the extracted layers.\n\t\t * @returns {*|Array}\n\t\t * @private\n\t\t */ _extractNonGroupLayers: function(group, output) {\n            var layers = group.getLayers(), i = 0, layer;\n            output = output || [];\n            for(; i < layers.length; i++){\n                layer = layers[i];\n                if (layer instanceof L.LayerGroup) {\n                    this._extractNonGroupLayers(layer, output);\n                    continue;\n                }\n                output.push(layer);\n            }\n            return output;\n        },\n        /**\n\t\t * Implements the singleMarkerMode option.\n\t\t * @param layer Marker to re-style using the Clusters iconCreateFunction.\n\t\t * @returns {L.Icon} The newly created icon.\n\t\t * @private\n\t\t */ _overrideMarkerIcon: function(layer) {\n            var icon = layer.options.icon = this.options.iconCreateFunction({\n                getChildCount: function() {\n                    return 1;\n                },\n                getAllChildMarkers: function() {\n                    return [\n                        layer\n                    ];\n                }\n            });\n            return icon;\n        }\n    });\n    // Constant bounds used in case option \"removeOutsideVisibleBounds\" is set to false.\n    L.MarkerClusterGroup.include({\n        _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))\n    });\n    L.MarkerClusterGroup.include({\n        _noAnimation: {\n            //Non Animated versions of everything\n            _animationStart: function() {\n            //Do nothing...\n            },\n            _animationZoomIn: function(previousZoomLevel, newZoomLevel) {\n                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n                //We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n                this.fire(\"animationend\");\n            },\n            _animationZoomOut: function(previousZoomLevel, newZoomLevel) {\n                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n                //We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n                this.fire(\"animationend\");\n            },\n            _animationAddLayer: function(layer, newCluster) {\n                this._animationAddLayerNonAnimated(layer, newCluster);\n            }\n        },\n        _withAnimation: {\n            //Animated versions here\n            _animationStart: function() {\n                this._map._mapPane.className += \" leaflet-cluster-anim\";\n                this._inZoomAnimation++;\n            },\n            _animationZoomIn: function(previousZoomLevel, newZoomLevel) {\n                var bounds = this._getExpandedVisibleBounds(), fg = this._featureGroup, minZoom = Math.floor(this._map.getMinZoom()), i;\n                this._ignoreMove = true;\n                //Add all children of current clusters to map and remove those clusters from map\n                this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function(c) {\n                    var startPos = c._latlng, markers = c._markers, m;\n                    if (!bounds.contains(startPos)) {\n                        startPos = null;\n                    }\n                    if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) {\n                        fg.removeLayer(c);\n                        c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n                    } else {\n                        //Fade out old cluster\n                        c.clusterHide();\n                        c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n                    }\n                    //Remove all markers that aren't visible any more\n                    //TODO: Do we actually need to do this on the higher levels too?\n                    for(i = markers.length - 1; i >= 0; i--){\n                        m = markers[i];\n                        if (!bounds.contains(m._latlng)) {\n                            fg.removeLayer(m);\n                        }\n                    }\n                });\n                this._forceLayout();\n                //Update opacities\n                this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n                //TODO Maybe? Update markers in _recursivelyBecomeVisible\n                fg.eachLayer(function(n) {\n                    if (!(n instanceof L.MarkerCluster) && n._icon) {\n                        n.clusterShow();\n                    }\n                });\n                //update the positions of the just added clusters/markers\n                this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function(c) {\n                    c._recursivelyRestoreChildPositions(newZoomLevel);\n                });\n                this._ignoreMove = false;\n                //Remove the old clusters and close the zoom animation\n                this._enqueue(function() {\n                    //update the positions of the just added clusters/markers\n                    this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function(c) {\n                        fg.removeLayer(c);\n                        c.clusterShow();\n                    });\n                    this._animationEnd();\n                });\n            },\n            _animationZoomOut: function(previousZoomLevel, newZoomLevel) {\n                this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n                //Need to add markers for those that weren't on the map before but are now\n                this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n                //Remove markers that were on the map before but won't be now\n                this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\n            },\n            _animationAddLayer: function(layer, newCluster) {\n                var me = this, fg = this._featureGroup;\n                fg.addLayer(layer);\n                if (newCluster !== layer) {\n                    if (newCluster._childCount > 2) {\n                        newCluster._updateIcon();\n                        this._forceLayout();\n                        this._animationStart();\n                        layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n                        layer.clusterHide();\n                        this._enqueue(function() {\n                            fg.removeLayer(layer);\n                            layer.clusterShow();\n                            me._animationEnd();\n                        });\n                    } else {\n                        this._forceLayout();\n                        me._animationStart();\n                        me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\n                    }\n                }\n            }\n        },\n        // Private methods for animated versions.\n        _animationZoomOutSingle: function(cluster, previousZoomLevel, newZoomLevel) {\n            var bounds = this._getExpandedVisibleBounds(), minZoom = Math.floor(this._map.getMinZoom());\n            //Animate all of the markers in the clusters to move to their cluster center point\n            cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\n            var me = this;\n            //Update the opacity (If we immediately set it they won't animate)\n            this._forceLayout();\n            cluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n            //TODO: Maybe use the transition timing stuff to make this more reliable\n            //When the animations are done, tidy up\n            this._enqueue(function() {\n                //This cluster stopped being a cluster before the timeout fired\n                if (cluster._childCount === 1) {\n                    var m = cluster._markers[0];\n                    //If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n                    this._ignoreMove = true;\n                    m.setLatLng(m.getLatLng());\n                    this._ignoreMove = false;\n                    if (m.clusterShow) {\n                        m.clusterShow();\n                    }\n                } else {\n                    cluster._recursively(bounds, newZoomLevel, minZoom, function(c) {\n                        c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);\n                    });\n                }\n                me._animationEnd();\n            });\n        },\n        _animationEnd: function() {\n            if (this._map) {\n                this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\");\n            }\n            this._inZoomAnimation--;\n            this.fire(\"animationend\");\n        },\n        //Force a browser layout of stuff in the map\n        // Should apply the current opacity and location to all elements so we can update them again for an animation\n        _forceLayout: function() {\n            //In my testing this works, infact offsetWidth of any element seems to work.\n            //Could loop all this._layers and do this for each _icon if it stops working\n            L.Util.falseFn(document.body.offsetWidth);\n        }\n    });\n    L.markerClusterGroup = function(options) {\n        return new L.MarkerClusterGroup(options);\n    };\n    var MarkerCluster = L.MarkerCluster = L.Marker.extend({\n        options: L.Icon.prototype.options,\n        initialize: function(group, zoom, a, b) {\n            L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), {\n                icon: this,\n                pane: group.options.clusterPane\n            });\n            this._group = group;\n            this._zoom = zoom;\n            this._markers = [];\n            this._childClusters = [];\n            this._childCount = 0;\n            this._iconNeedsUpdate = true;\n            this._boundsNeedUpdate = true;\n            this._bounds = new L.LatLngBounds();\n            if (a) {\n                this._addChild(a);\n            }\n            if (b) {\n                this._addChild(b);\n            }\n        },\n        //Recursively retrieve all child markers of this cluster\n        getAllChildMarkers: function(storageArray, ignoreDraggedMarker) {\n            storageArray = storageArray || [];\n            for(var i = this._childClusters.length - 1; i >= 0; i--){\n                this._childClusters[i].getAllChildMarkers(storageArray, ignoreDraggedMarker);\n            }\n            for(var j = this._markers.length - 1; j >= 0; j--){\n                if (ignoreDraggedMarker && this._markers[j].__dragStart) {\n                    continue;\n                }\n                storageArray.push(this._markers[j]);\n            }\n            return storageArray;\n        },\n        //Returns the count of how many child markers we have\n        getChildCount: function() {\n            return this._childCount;\n        },\n        //Zoom to the minimum of showing all of the child markers, or the extents of this cluster\n        zoomToBounds: function(fitBoundsOptions) {\n            var childClusters = this._childClusters.slice(), map = this._group._map, boundsZoom = map.getBoundsZoom(this._bounds), zoom = this._zoom + 1, mapZoom = map.getZoom(), i;\n            //calculate how far we need to zoom down to see all of the markers\n            while(childClusters.length > 0 && boundsZoom > zoom){\n                zoom++;\n                var newClusters = [];\n                for(i = 0; i < childClusters.length; i++){\n                    newClusters = newClusters.concat(childClusters[i]._childClusters);\n                }\n                childClusters = newClusters;\n            }\n            if (boundsZoom > zoom) {\n                this._group._map.setView(this._latlng, zoom);\n            } else if (boundsZoom <= mapZoom) {\n                this._group._map.setView(this._latlng, mapZoom + 1);\n            } else {\n                this._group._map.fitBounds(this._bounds, fitBoundsOptions);\n            }\n        },\n        getBounds: function() {\n            var bounds = new L.LatLngBounds();\n            bounds.extend(this._bounds);\n            return bounds;\n        },\n        _updateIcon: function() {\n            this._iconNeedsUpdate = true;\n            if (this._icon) {\n                this.setIcon(this);\n            }\n        },\n        //Cludge for Icon, we pretend to be an icon for performance\n        createIcon: function() {\n            if (this._iconNeedsUpdate) {\n                this._iconObj = this._group.options.iconCreateFunction(this);\n                this._iconNeedsUpdate = false;\n            }\n            return this._iconObj.createIcon();\n        },\n        createShadow: function() {\n            return this._iconObj.createShadow();\n        },\n        _addChild: function(new1, isNotificationFromChild) {\n            this._iconNeedsUpdate = true;\n            this._boundsNeedUpdate = true;\n            this._setClusterCenter(new1);\n            if (new1 instanceof L.MarkerCluster) {\n                if (!isNotificationFromChild) {\n                    this._childClusters.push(new1);\n                    new1.__parent = this;\n                }\n                this._childCount += new1._childCount;\n            } else {\n                if (!isNotificationFromChild) {\n                    this._markers.push(new1);\n                }\n                this._childCount++;\n            }\n            if (this.__parent) {\n                this.__parent._addChild(new1, true);\n            }\n        },\n        /**\n\t\t * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.\n\t\t * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.\n\t\t * @private\n\t\t */ _setClusterCenter: function(child) {\n            if (!this._cLatLng) {\n                // when clustering, take position of the first point as the cluster center\n                this._cLatLng = child._cLatLng || child._latlng;\n            }\n        },\n        /**\n\t\t * Assigns impossible bounding values so that the next extend entirely determines the new bounds.\n\t\t * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.\n\t\t * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.\n\t\t * @private\n\t\t */ _resetBounds: function() {\n            var bounds = this._bounds;\n            if (bounds._southWest) {\n                bounds._southWest.lat = Infinity;\n                bounds._southWest.lng = Infinity;\n            }\n            if (bounds._northEast) {\n                bounds._northEast.lat = -Infinity;\n                bounds._northEast.lng = -Infinity;\n            }\n        },\n        _recalculateBounds: function() {\n            var markers = this._markers, childClusters = this._childClusters, latSum = 0, lngSum = 0, totalCount = this._childCount, i, child, childLatLng, childCount;\n            // Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.\n            if (totalCount === 0) {\n                return;\n            }\n            // Reset rather than creating a new object, for performance.\n            this._resetBounds();\n            // Child markers.\n            for(i = 0; i < markers.length; i++){\n                childLatLng = markers[i]._latlng;\n                this._bounds.extend(childLatLng);\n                latSum += childLatLng.lat;\n                lngSum += childLatLng.lng;\n            }\n            // Child clusters.\n            for(i = 0; i < childClusters.length; i++){\n                child = childClusters[i];\n                // Re-compute child bounds and weighted position first if necessary.\n                if (child._boundsNeedUpdate) {\n                    child._recalculateBounds();\n                }\n                this._bounds.extend(child._bounds);\n                childLatLng = child._wLatLng;\n                childCount = child._childCount;\n                latSum += childLatLng.lat * childCount;\n                lngSum += childLatLng.lng * childCount;\n            }\n            this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);\n            // Reset dirty flag.\n            this._boundsNeedUpdate = false;\n        },\n        //Set our markers position as given and add it to the map\n        _addToMap: function(startPos) {\n            if (startPos) {\n                this._backupLatlng = this._latlng;\n                this.setLatLng(startPos);\n            }\n            this._group._featureGroup.addLayer(this);\n        },\n        _recursivelyAnimateChildrenIn: function(bounds, center, maxZoom) {\n            this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1, function(c) {\n                var markers = c._markers, i, m;\n                for(i = markers.length - 1; i >= 0; i--){\n                    m = markers[i];\n                    //Only do it if the icon is still on the map\n                    if (m._icon) {\n                        m._setPos(center);\n                        m.clusterHide();\n                    }\n                }\n            }, function(c) {\n                var childClusters = c._childClusters, j, cm;\n                for(j = childClusters.length - 1; j >= 0; j--){\n                    cm = childClusters[j];\n                    if (cm._icon) {\n                        cm._setPos(center);\n                        cm.clusterHide();\n                    }\n                }\n            });\n        },\n        _recursivelyAnimateChildrenInAndAddSelfToMap: function(bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {\n            this._recursively(bounds, newZoomLevel, mapMinZoom, function(c) {\n                c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n                //TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n                //As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n                if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n                    c.clusterShow();\n                    c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n                } else {\n                    c.clusterHide();\n                }\n                c._addToMap();\n            });\n        },\n        _recursivelyBecomeVisible: function(bounds, zoomLevel) {\n            this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function(c) {\n                c.clusterShow();\n            });\n        },\n        _recursivelyAddChildrenToMap: function(startPos, zoomLevel, bounds) {\n            this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel, function(c) {\n                if (zoomLevel === c._zoom) {\n                    return;\n                }\n                //Add our child markers at startPos (so they can be animated out)\n                for(var i = c._markers.length - 1; i >= 0; i--){\n                    var nm = c._markers[i];\n                    if (!bounds.contains(nm._latlng)) {\n                        continue;\n                    }\n                    if (startPos) {\n                        nm._backupLatlng = nm.getLatLng();\n                        nm.setLatLng(startPos);\n                        if (nm.clusterHide) {\n                            nm.clusterHide();\n                        }\n                    }\n                    c._group._featureGroup.addLayer(nm);\n                }\n            }, function(c) {\n                c._addToMap(startPos);\n            });\n        },\n        _recursivelyRestoreChildPositions: function(zoomLevel) {\n            //Fix positions of child markers\n            for(var i = this._markers.length - 1; i >= 0; i--){\n                var nm = this._markers[i];\n                if (nm._backupLatlng) {\n                    nm.setLatLng(nm._backupLatlng);\n                    delete nm._backupLatlng;\n                }\n            }\n            if (zoomLevel - 1 === this._zoom) {\n                //Reposition child clusters\n                for(var j = this._childClusters.length - 1; j >= 0; j--){\n                    this._childClusters[j]._restorePosition();\n                }\n            } else {\n                for(var k = this._childClusters.length - 1; k >= 0; k--){\n                    this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n                }\n            }\n        },\n        _restorePosition: function() {\n            if (this._backupLatlng) {\n                this.setLatLng(this._backupLatlng);\n                delete this._backupLatlng;\n            }\n        },\n        //exceptBounds: If set, don't remove any markers/clusters in it\n        _recursivelyRemoveChildrenFromMap: function(previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\n            var m, i;\n            this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1, function(c) {\n                //Remove markers at every level\n                for(i = c._markers.length - 1; i >= 0; i--){\n                    m = c._markers[i];\n                    if (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n                        c._group._featureGroup.removeLayer(m);\n                        if (m.clusterShow) {\n                            m.clusterShow();\n                        }\n                    }\n                }\n            }, function(c) {\n                //Remove child clusters at just the bottom level\n                for(i = c._childClusters.length - 1; i >= 0; i--){\n                    m = c._childClusters[i];\n                    if (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n                        c._group._featureGroup.removeLayer(m);\n                        if (m.clusterShow) {\n                            m.clusterShow();\n                        }\n                    }\n                }\n            });\n        },\n        //Run the given functions recursively to this and child clusters\n        // boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n        // zoomLevelToStart: zoom level to start running functions (inclusive)\n        // zoomLevelToStop: zoom level to stop running functions (inclusive)\n        // runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n        // runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n        _recursively: function(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n            var childClusters = this._childClusters, zoom = this._zoom, i, c;\n            if (zoomLevelToStart <= zoom) {\n                if (runAtEveryLevel) {\n                    runAtEveryLevel(this);\n                }\n                if (runAtBottomLevel && zoom === zoomLevelToStop) {\n                    runAtBottomLevel(this);\n                }\n            }\n            if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\n                for(i = childClusters.length - 1; i >= 0; i--){\n                    c = childClusters[i];\n                    if (c._boundsNeedUpdate) {\n                        c._recalculateBounds();\n                    }\n                    if (boundsToApplyTo.intersects(c._bounds)) {\n                        c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n                    }\n                }\n            }\n        },\n        //Returns true if we are the parent of only one cluster and that cluster is the same as us\n        _isSingleParent: function() {\n            //Don't need to check this._markers as the rest won't work if there are any\n            return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n        }\n    });\n    /*\n\t* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\n\t* \n\t* They work as setOpacity(0) and setOpacity(1) respectively, but\n\t* don't overwrite the options.opacity\n\t* \n\t*/ L.Marker.include({\n        clusterHide: function() {\n            var backup = this.options.opacity;\n            this.setOpacity(0);\n            this.options.opacity = backup;\n            return this;\n        },\n        clusterShow: function() {\n            return this.setOpacity(this.options.opacity);\n        }\n    });\n    L.DistanceGrid = function(cellSize) {\n        this._cellSize = cellSize;\n        this._sqCellSize = cellSize * cellSize;\n        this._grid = {};\n        this._objectPoint = {};\n    };\n    L.DistanceGrid.prototype = {\n        addObject: function(obj, point) {\n            var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], stamp = L.Util.stamp(obj);\n            this._objectPoint[stamp] = point;\n            cell.push(obj);\n        },\n        updateObject: function(obj, point) {\n            this.removeObject(obj);\n            this.addObject(obj, point);\n        },\n        //Returns true if the object was found\n        removeObject: function(obj, point) {\n            var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], i, len;\n            delete this._objectPoint[L.Util.stamp(obj)];\n            for(i = 0, len = cell.length; i < len; i++){\n                if (cell[i] === obj) {\n                    cell.splice(i, 1);\n                    if (len === 1) {\n                        delete row[x];\n                    }\n                    return true;\n                }\n            }\n        },\n        eachObject: function(fn, context) {\n            var i, j, k, len, row, cell, removed, grid = this._grid;\n            for(i in grid){\n                row = grid[i];\n                for(j in row){\n                    cell = row[j];\n                    for(k = 0, len = cell.length; k < len; k++){\n                        removed = fn.call(context, cell[k]);\n                        if (removed) {\n                            k--;\n                            len--;\n                        }\n                    }\n                }\n            }\n        },\n        getNearObject: function(point) {\n            var x = this._getCoord(point.x), y = this._getCoord(point.y), i, j, k, row, cell, len, obj, dist, objectPoint = this._objectPoint, closestDistSq = this._sqCellSize, closest = null;\n            for(i = y - 1; i <= y + 1; i++){\n                row = this._grid[i];\n                if (row) {\n                    for(j = x - 1; j <= x + 1; j++){\n                        cell = row[j];\n                        if (cell) {\n                            for(k = 0, len = cell.length; k < len; k++){\n                                obj = cell[k];\n                                dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n                                if (dist < closestDistSq || dist <= closestDistSq && closest === null) {\n                                    closestDistSq = dist;\n                                    closest = obj;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return closest;\n        },\n        _getCoord: function(x) {\n            var coord = Math.floor(x / this._cellSize);\n            return isFinite(coord) ? coord : x;\n        },\n        _sqDist: function(p, p2) {\n            var dx = p2.x - p.x, dy = p2.y - p.y;\n            return dx * dx + dy * dy;\n        }\n    };\n    /* Copyright (c) 2012 the authors listed at the following URL, and/or\n\tthe authors of referenced articles or incorporated external code:\n\thttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\n\tPermission is hereby granted, free of charge, to any person obtaining\n\ta copy of this software and associated documentation files (the\n\t\"Software\"), to deal in the Software without restriction, including\n\twithout limitation the rights to use, copy, modify, merge, publish,\n\tdistribute, sublicense, and/or sell copies of the Software, and to\n\tpermit persons to whom the Software is furnished to do so, subject to\n\tthe following conditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\tMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n\tCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n\tTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n\t*/ (function() {\n        L.QuickHull = {\n            /*\n\t\t\t * @param {Object} cpt a point to be measured from the baseline\n\t\t\t * @param {Array} bl the baseline, as represented by a two-element\n\t\t\t *   array of latlng objects.\n\t\t\t * @returns {Number} an approximate distance measure\n\t\t\t */ getDistant: function(cpt, bl) {\n                var vY = bl[1].lat - bl[0].lat, vX = bl[0].lng - bl[1].lng;\n                return vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);\n            },\n            /*\n\t\t\t * @param {Array} baseLine a two-element array of latlng objects\n\t\t\t *   representing the baseline to project from\n\t\t\t * @param {Array} latLngs an array of latlng objects\n\t\t\t * @returns {Object} the maximum point and all new points to stay\n\t\t\t *   in consideration for the hull.\n\t\t\t */ findMostDistantPointFromBaseLine: function(baseLine, latLngs) {\n                var maxD = 0, maxPt = null, newPoints = [], i, pt, d;\n                for(i = latLngs.length - 1; i >= 0; i--){\n                    pt = latLngs[i];\n                    d = this.getDistant(pt, baseLine);\n                    if (d > 0) {\n                        newPoints.push(pt);\n                    } else {\n                        continue;\n                    }\n                    if (d > maxD) {\n                        maxD = d;\n                        maxPt = pt;\n                    }\n                }\n                return {\n                    maxPoint: maxPt,\n                    newPoints: newPoints\n                };\n            },\n            /*\n\t\t\t * Given a baseline, compute the convex hull of latLngs as an array\n\t\t\t * of latLngs.\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */ buildConvexHull: function(baseLine, latLngs) {\n                var convexHullBaseLines = [], t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n                if (t.maxPoint) {\n                    convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([\n                        baseLine[0],\n                        t.maxPoint\n                    ], t.newPoints));\n                    convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([\n                        t.maxPoint,\n                        baseLine[1]\n                    ], t.newPoints));\n                    return convexHullBaseLines;\n                } else {\n                    return [\n                        baseLine[0]\n                    ];\n                }\n            },\n            /*\n\t\t\t * Given an array of latlngs, compute a convex hull as an array\n\t\t\t * of latlngs\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */ getConvexHull: function(latLngs) {\n                // find first baseline\n                var maxLat = false, minLat = false, maxLng = false, minLng = false, maxLatPt = null, minLatPt = null, maxLngPt = null, minLngPt = null, maxPt = null, minPt = null, i;\n                for(i = latLngs.length - 1; i >= 0; i--){\n                    var pt = latLngs[i];\n                    if (maxLat === false || pt.lat > maxLat) {\n                        maxLatPt = pt;\n                        maxLat = pt.lat;\n                    }\n                    if (minLat === false || pt.lat < minLat) {\n                        minLatPt = pt;\n                        minLat = pt.lat;\n                    }\n                    if (maxLng === false || pt.lng > maxLng) {\n                        maxLngPt = pt;\n                        maxLng = pt.lng;\n                    }\n                    if (minLng === false || pt.lng < minLng) {\n                        minLngPt = pt;\n                        minLng = pt.lng;\n                    }\n                }\n                if (minLat !== maxLat) {\n                    minPt = minLatPt;\n                    maxPt = maxLatPt;\n                } else {\n                    minPt = minLngPt;\n                    maxPt = maxLngPt;\n                }\n                var ch = [].concat(this.buildConvexHull([\n                    minPt,\n                    maxPt\n                ], latLngs), this.buildConvexHull([\n                    maxPt,\n                    minPt\n                ], latLngs));\n                return ch;\n            }\n        };\n    })();\n    L.MarkerCluster.include({\n        getConvexHull: function() {\n            var childMarkers = this.getAllChildMarkers(), points = [], p, i;\n            for(i = childMarkers.length - 1; i >= 0; i--){\n                p = childMarkers[i].getLatLng();\n                points.push(p);\n            }\n            return L.QuickHull.getConvexHull(points);\n        }\n    });\n    //This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n    //Huge thanks to jawj for implementing it first to make my job easy :-)\n    L.MarkerCluster.include({\n        _2PI: Math.PI * 2,\n        _circleFootSeparation: 25,\n        _circleStartAngle: 0,\n        _spiralFootSeparation: 28,\n        _spiralLengthStart: 11,\n        _spiralLengthFactor: 5,\n        _circleSpiralSwitchover: 9,\n        // 0 -> always spiral; Infinity -> always circle\n        spiderfy: function() {\n            if (this._group._spiderfied === this || this._group._inZoomAnimation) {\n                return;\n            }\n            var childMarkers = this.getAllChildMarkers(null, true), group = this._group, map = group._map, center = map.latLngToLayerPoint(this._latlng), positions;\n            this._group._unspiderfy();\n            this._group._spiderfied = this;\n            //TODO Maybe: childMarkers order by distance to center\n            if (this._group.options.spiderfyShapePositions) {\n                positions = this._group.options.spiderfyShapePositions(childMarkers.length, center);\n            } else if (childMarkers.length >= this._circleSpiralSwitchover) {\n                positions = this._generatePointsSpiral(childMarkers.length, center);\n            } else {\n                center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.\n                positions = this._generatePointsCircle(childMarkers.length, center);\n            }\n            this._animationSpiderfy(childMarkers, positions);\n        },\n        unspiderfy: function(zoomDetails) {\n            /// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n            if (this._group._inZoomAnimation) {\n                return;\n            }\n            this._animationUnspiderfy(zoomDetails);\n            this._group._spiderfied = null;\n        },\n        _generatePointsCircle: function(count, centerPt) {\n            var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count), legLength = circumference / this._2PI, angleStep = this._2PI / count, res = [], i, angle;\n            legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.\n            res.length = count;\n            for(i = 0; i < count; i++){\n                angle = this._circleStartAngle + i * angleStep;\n                res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n            }\n            return res;\n        },\n        _generatePointsSpiral: function(count, centerPt) {\n            var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier, legLength = spiderfyDistanceMultiplier * this._spiralLengthStart, separation = spiderfyDistanceMultiplier * this._spiralFootSeparation, lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI, angle = 0, res = [], i;\n            res.length = count;\n            // Higher index, closer position to cluster center.\n            for(i = count; i >= 0; i--){\n                // Skip the first position, so that we are already farther from center and we avoid\n                // being under the default cluster icon (especially important for Circle Markers).\n                if (i < count) {\n                    res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n                }\n                angle += separation / legLength + i * 0.0005;\n                legLength += lengthFactor / angle;\n            }\n            return res;\n        },\n        _noanimationUnspiderfy: function() {\n            var group = this._group, map = group._map, fg = group._featureGroup, childMarkers = this.getAllChildMarkers(null, true), m, i;\n            group._ignoreMove = true;\n            this.setOpacity(1);\n            for(i = childMarkers.length - 1; i >= 0; i--){\n                m = childMarkers[i];\n                fg.removeLayer(m);\n                if (m._preSpiderfyLatlng) {\n                    m.setLatLng(m._preSpiderfyLatlng);\n                    delete m._preSpiderfyLatlng;\n                }\n                if (m.setZIndexOffset) {\n                    m.setZIndexOffset(0);\n                }\n                if (m._spiderLeg) {\n                    map.removeLayer(m._spiderLeg);\n                    delete m._spiderLeg;\n                }\n            }\n            group.fire(\"unspiderfied\", {\n                cluster: this,\n                markers: childMarkers\n            });\n            group._ignoreMove = false;\n            group._spiderfied = null;\n        }\n    });\n    //Non Animated versions of everything\n    L.MarkerClusterNonAnimated = L.MarkerCluster.extend({\n        _animationSpiderfy: function(childMarkers, positions) {\n            var group = this._group, map = group._map, fg = group._featureGroup, legOptions = this._group.options.spiderLegPolylineOptions, i, m, leg, newPos;\n            group._ignoreMove = true;\n            // Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n            // The reverse order trick no longer improves performance on modern browsers.\n            for(i = 0; i < childMarkers.length; i++){\n                newPos = map.layerPointToLatLng(positions[i]);\n                m = childMarkers[i];\n                // Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n                leg = new L.Polyline([\n                    this._latlng,\n                    newPos\n                ], legOptions);\n                map.addLayer(leg);\n                m._spiderLeg = leg;\n                // Now add the marker.\n                m._preSpiderfyLatlng = m._latlng;\n                m.setLatLng(newPos);\n                if (m.setZIndexOffset) {\n                    m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n                }\n                fg.addLayer(m);\n            }\n            this.setOpacity(0.3);\n            group._ignoreMove = false;\n            group.fire(\"spiderfied\", {\n                cluster: this,\n                markers: childMarkers\n            });\n        },\n        _animationUnspiderfy: function() {\n            this._noanimationUnspiderfy();\n        }\n    });\n    //Animated versions here\n    L.MarkerCluster.include({\n        _animationSpiderfy: function(childMarkers, positions) {\n            var me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerLatLng = this._latlng, thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng), svg = L.Path.SVG, legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), finalLegOpacity = legOptions.opacity, i, m, leg, legPath, legLength, newPos;\n            if (finalLegOpacity === undefined) {\n                finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;\n            }\n            if (svg) {\n                // If the initial opacity of the spider leg is not 0 then it appears before the animation starts.\n                legOptions.opacity = 0;\n                // Add the class for CSS transitions.\n                legOptions.className = (legOptions.className || \"\") + \" leaflet-cluster-spider-leg\";\n            } else {\n                // Make sure we have a defined opacity.\n                legOptions.opacity = finalLegOpacity;\n            }\n            group._ignoreMove = true;\n            // Add markers and spider legs to map, hidden at our center point.\n            // Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n            // The reverse order trick no longer improves performance on modern browsers.\n            for(i = 0; i < childMarkers.length; i++){\n                m = childMarkers[i];\n                newPos = map.layerPointToLatLng(positions[i]);\n                // Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n                leg = new L.Polyline([\n                    thisLayerLatLng,\n                    newPos\n                ], legOptions);\n                map.addLayer(leg);\n                m._spiderLeg = leg;\n                // Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/\n                // In our case the transition property is declared in the CSS file.\n                if (svg) {\n                    legPath = leg._path;\n                    legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.\n                    legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.\n                    legPath.style.strokeDashoffset = legLength;\n                }\n                // If it is a marker, add it now and we'll animate it out\n                if (m.setZIndexOffset) {\n                    m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\n                }\n                if (m.clusterHide) {\n                    m.clusterHide();\n                }\n                // Vectors just get immediately added\n                fg.addLayer(m);\n                if (m._setPos) {\n                    m._setPos(thisLayerPos);\n                }\n            }\n            group._forceLayout();\n            group._animationStart();\n            // Reveal markers and spider legs.\n            for(i = childMarkers.length - 1; i >= 0; i--){\n                newPos = map.layerPointToLatLng(positions[i]);\n                m = childMarkers[i];\n                //Move marker to new position\n                m._preSpiderfyLatlng = m._latlng;\n                m.setLatLng(newPos);\n                if (m.clusterShow) {\n                    m.clusterShow();\n                }\n                // Animate leg (animation is actually delegated to CSS transition).\n                if (svg) {\n                    leg = m._spiderLeg;\n                    legPath = leg._path;\n                    legPath.style.strokeDashoffset = 0;\n                    //legPath.style.strokeOpacity = finalLegOpacity;\n                    leg.setStyle({\n                        opacity: finalLegOpacity\n                    });\n                }\n            }\n            this.setOpacity(0.3);\n            group._ignoreMove = false;\n            setTimeout(function() {\n                group._animationEnd();\n                group.fire(\"spiderfied\", {\n                    cluster: me,\n                    markers: childMarkers\n                });\n            }, 200);\n        },\n        _animationUnspiderfy: function(zoomDetails) {\n            var me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng), childMarkers = this.getAllChildMarkers(null, true), svg = L.Path.SVG, m, i, leg, legPath, legLength, nonAnimatable;\n            group._ignoreMove = true;\n            group._animationStart();\n            //Make us visible and bring the child markers back in\n            this.setOpacity(1);\n            for(i = childMarkers.length - 1; i >= 0; i--){\n                m = childMarkers[i];\n                //Marker was added to us after we were spiderfied\n                if (!m._preSpiderfyLatlng) {\n                    continue;\n                }\n                //Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\n                m.closePopup();\n                //Fix up the location to the real one\n                m.setLatLng(m._preSpiderfyLatlng);\n                delete m._preSpiderfyLatlng;\n                //Hack override the location to be our center\n                nonAnimatable = true;\n                if (m._setPos) {\n                    m._setPos(thisLayerPos);\n                    nonAnimatable = false;\n                }\n                if (m.clusterHide) {\n                    m.clusterHide();\n                    nonAnimatable = false;\n                }\n                if (nonAnimatable) {\n                    fg.removeLayer(m);\n                }\n                // Animate the spider leg back in (animation is actually delegated to CSS transition).\n                if (svg) {\n                    leg = m._spiderLeg;\n                    legPath = leg._path;\n                    legLength = legPath.getTotalLength() + 0.1;\n                    legPath.style.strokeDashoffset = legLength;\n                    leg.setStyle({\n                        opacity: 0\n                    });\n                }\n            }\n            group._ignoreMove = false;\n            setTimeout(function() {\n                //If we have only <= one child left then that marker will be shown on the map so don't remove it!\n                var stillThereChildCount = 0;\n                for(i = childMarkers.length - 1; i >= 0; i--){\n                    m = childMarkers[i];\n                    if (m._spiderLeg) {\n                        stillThereChildCount++;\n                    }\n                }\n                for(i = childMarkers.length - 1; i >= 0; i--){\n                    m = childMarkers[i];\n                    if (!m._spiderLeg) {\n                        continue;\n                    }\n                    if (m.clusterShow) {\n                        m.clusterShow();\n                    }\n                    if (m.setZIndexOffset) {\n                        m.setZIndexOffset(0);\n                    }\n                    if (stillThereChildCount > 1) {\n                        fg.removeLayer(m);\n                    }\n                    map.removeLayer(m._spiderLeg);\n                    delete m._spiderLeg;\n                }\n                group._animationEnd();\n                group.fire(\"unspiderfied\", {\n                    cluster: me,\n                    markers: childMarkers\n                });\n            }, 200);\n        }\n    });\n    L.MarkerClusterGroup.include({\n        //The MarkerCluster currently spiderfied (if any)\n        _spiderfied: null,\n        unspiderfy: function() {\n            this._unspiderfy.apply(this, arguments);\n        },\n        _spiderfierOnAdd: function() {\n            this._map.on(\"click\", this._unspiderfyWrapper, this);\n            if (this._map.options.zoomAnimation) {\n                this._map.on(\"zoomstart\", this._unspiderfyZoomStart, this);\n            }\n            //Browsers without zoomAnimation or a big zoom don't fire zoomstart\n            this._map.on(\"zoomend\", this._noanimationUnspiderfy, this);\n            if (!L.Browser.touch) {\n                this._map.getRenderer(this);\n            //Needs to happen in the pageload, not after, or animations don't work in webkit\n            //  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n            //Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n            }\n        },\n        _spiderfierOnRemove: function() {\n            this._map.off(\"click\", this._unspiderfyWrapper, this);\n            this._map.off(\"zoomstart\", this._unspiderfyZoomStart, this);\n            this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this);\n            this._map.off(\"zoomend\", this._noanimationUnspiderfy, this);\n            //Ensure that markers are back where they should be\n            // Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane\n            this._noanimationUnspiderfy();\n        },\n        //On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n        //This means we can define the animation they do rather than Markers doing an animation to their actual location\n        _unspiderfyZoomStart: function() {\n            if (!this._map) {\n                return;\n            }\n            this._map.on(\"zoomanim\", this._unspiderfyZoomAnim, this);\n        },\n        _unspiderfyZoomAnim: function(zoomDetails) {\n            //Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n            if (L.DomUtil.hasClass(this._map._mapPane, \"leaflet-touching\")) {\n                return;\n            }\n            this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this);\n            this._unspiderfy(zoomDetails);\n        },\n        _unspiderfyWrapper: function() {\n            /// <summary>_unspiderfy but passes no arguments</summary>\n            this._unspiderfy();\n        },\n        _unspiderfy: function(zoomDetails) {\n            if (this._spiderfied) {\n                this._spiderfied.unspiderfy(zoomDetails);\n            }\n        },\n        _noanimationUnspiderfy: function() {\n            if (this._spiderfied) {\n                this._spiderfied._noanimationUnspiderfy();\n            }\n        },\n        //If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n        _unspiderfyLayer: function(layer) {\n            if (layer._spiderLeg) {\n                this._featureGroup.removeLayer(layer);\n                if (layer.clusterShow) {\n                    layer.clusterShow();\n                }\n                //Position will be fixed up immediately in _animationUnspiderfy\n                if (layer.setZIndexOffset) {\n                    layer.setZIndexOffset(0);\n                }\n                this._map.removeLayer(layer._spiderLeg);\n                delete layer._spiderLeg;\n            }\n        }\n    });\n    /**\n\t * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing\n\t * markers' icon options and refreshing their icon and their parent clusters\n\t * accordingly (case where their iconCreateFunction uses data of childMarkers\n\t * to make up the cluster icon).\n\t */ L.MarkerClusterGroup.include({\n        /**\n\t\t * Updates the icon of all clusters which are parents of the given marker(s).\n\t\t * In singleMarkerMode, also updates the given marker(s) icon.\n\t\t * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\n\t\t * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\n\t\t * clusters need to be updated. If not provided, retrieves all child markers of this.\n\t\t * @returns {L.MarkerClusterGroup}\n\t\t */ refreshClusters: function(layers) {\n            if (!layers) {\n                layers = this._topClusterLevel.getAllChildMarkers();\n            } else if (layers instanceof L.MarkerClusterGroup) {\n                layers = layers._topClusterLevel.getAllChildMarkers();\n            } else if (layers instanceof L.LayerGroup) {\n                layers = layers._layers;\n            } else if (layers instanceof L.MarkerCluster) {\n                layers = layers.getAllChildMarkers();\n            } else if (layers instanceof L.Marker) {\n                layers = [\n                    layers\n                ];\n            } // else: must be an Array(L.Marker)|Map(L.Marker)\n            this._flagParentsIconsNeedUpdate(layers);\n            this._refreshClustersIcons();\n            // In case of singleMarkerMode, also re-draw the markers.\n            if (this.options.singleMarkerMode) {\n                this._refreshSingleMarkerModeMarkers(layers);\n            }\n            return this;\n        },\n        /**\n\t\t * Simply flags all parent clusters of the given markers as having a \"dirty\" icon.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */ _flagParentsIconsNeedUpdate: function(layers) {\n            var id, parent;\n            // Assumes layers is an Array or an Object whose prototype is non-enumerable.\n            for(id in layers){\n                // Flag parent clusters' icon as \"dirty\", all the way up.\n                // Dumb process that flags multiple times upper parents, but still\n                // much more efficient than trying to be smart and make short lists,\n                // at least in the case of a hierarchy following a power law:\n                // http://jsperf.com/flag-nodes-in-power-hierarchy/2\n                parent = layers[id].__parent;\n                while(parent){\n                    parent._iconNeedsUpdate = true;\n                    parent = parent.__parent;\n                }\n            }\n        },\n        /**\n\t\t * Re-draws the icon of the supplied markers.\n\t\t * To be used in singleMarkerMode only.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */ _refreshSingleMarkerModeMarkers: function(layers) {\n            var id, layer;\n            for(id in layers){\n                layer = layers[id];\n                // Make sure we do not override markers that do not belong to THIS group.\n                if (this.hasLayer(layer)) {\n                    // Need to re-create the icon first, then re-draw the marker.\n                    layer.setIcon(this._overrideMarkerIcon(layer));\n                }\n            }\n        }\n    });\n    L.Marker.include({\n        /**\n\t\t * Updates the given options in the marker's icon and refreshes the marker.\n\t\t * @param options map object of icon options.\n\t\t * @param directlyRefreshClusters boolean (optional) true to trigger\n\t\t * MCG.refreshClustersOf() right away with this single marker.\n\t\t * @returns {L.Marker}\n\t\t */ refreshIconOptions: function(options, directlyRefreshClusters) {\n            var icon = this.options.icon;\n            L.setOptions(icon, options);\n            this.setIcon(icon);\n            // Shortcut to refresh the associated MCG clusters right away.\n            // To be used when refreshing a single marker.\n            // Otherwise, better use MCG.refreshClusters() once at the end with\n            // the list of modified markers.\n            if (directlyRefreshClusters && this.__parent) {\n                this.__parent._group.refreshClusters(this);\n            }\n            return this;\n        }\n    });\n    exports1.MarkerClusterGroup = MarkerClusterGroup;\n    exports1.MarkerCluster = MarkerCluster;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=leaflet.markercluster-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvZGlzdC9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBQ0EsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3pCLEtBQWlELEdBQWNBLFFBQVFDLFdBQ3ZFLENBQzZHO0FBQzlHLEdBQUUsSUFBSSxFQUFFLFNBQVVBLFFBQU87SUFBSTtJQUU1Qjs7RUFFQyxHQUVELElBQUlPLHFCQUFxQkMsRUFBRUQsa0JBQWtCLEdBQUdDLEVBQUVDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDO1FBRXJFQyxTQUFTO1lBQ1JDLGtCQUFrQjtZQUNsQkMsb0JBQW9CO1lBQ3BCQyxhQUFhTixFQUFFTyxNQUFNLENBQUNDLFNBQVMsQ0FBQ0wsT0FBTyxDQUFDTSxJQUFJO1lBRTVDQyxxQkFBcUI7WUFDckJDLG1CQUFtQjtZQUNuQkMscUJBQXFCO1lBQ3JCQyxxQkFBcUI7WUFDckJDLGtCQUFrQjtZQUVsQkMseUJBQXlCO1lBRXpCLDZGQUE2RjtZQUM3RixvREFBb0Q7WUFDcERDLDRCQUE0QjtZQUU1Qiw4REFBOEQ7WUFDOUQsNkRBQTZEO1lBQzdELCtEQUErRDtZQUMvREMsU0FBUztZQUVULGtGQUFrRjtZQUNsRixzSEFBc0g7WUFDdEhDLHNCQUFzQjtZQUV0QixvRkFBb0Y7WUFDcEZDLHdCQUF3QjtZQUV4Qix1RkFBdUY7WUFDdkZDLDRCQUE0QjtZQUU1QixpRUFBaUU7WUFDakVDLDBCQUEwQjtnQkFBRUMsUUFBUTtnQkFBS0MsT0FBTztnQkFBUUMsU0FBUztZQUFJO1lBRXJFLG9KQUFvSjtZQUNwSkMsZ0JBQWdCO1lBQ2hCQyxlQUFlO1lBQ2ZDLFlBQVk7WUFDWkMsZUFBZTtZQUVmLDhDQUE4QztZQUM5Q0MsZ0JBQWdCLENBQUM7UUFDbEI7UUFFQUMsWUFBWSxTQUFVM0IsT0FBTztZQUM1QkgsRUFBRStCLElBQUksQ0FBQ0MsVUFBVSxD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WUFDRDtRQUNEO1FBRUE7Ozs7O0dBS0MsR0FDRGdaLGlDQUFpQyxTQUFVblYsTUFBTTtZQUNoRCxJQUFJRSxJQUFJaEY7WUFFUixJQUFLZ0YsTUFBTUYsT0FBUTtnQkFDbEI5RSxRQUFROEUsTUFBTSxDQUFDRSxHQUFHO2dCQUVsQix5RUFBeUU7Z0JBQ3pFLElBQUksSUFBSSxDQUFDekUsUUFBUSxDQUFDUCxRQUFRO29CQUN6Qiw2REFBNkQ7b0JBQzdEQSxNQUFNeVEsT0FBTyxDQUFDLElBQUksQ0FBQ3pFLG1CQUFtQixDQUFDaE07Z0JBQ3hDO1lBQ0Q7UUFDRDtJQUNEO0lBRUF2RCxFQUFFTyxNQUFNLENBQUNtUixPQUFPLENBQUM7UUFDaEI7Ozs7OztHQU1DLEdBQ0QrTCxvQkFBb0IsU0FBVXRkLE9BQU8sRUFBRXVkLHVCQUF1QjtZQUM3RCxJQUFJak0sT0FBTyxJQUFJLENBQUN0UixPQUFPLENBQUNzUixJQUFJO1lBRTVCelIsRUFBRWdDLFVBQVUsQ0FBQ3lQLE1BQU10UjtZQUVuQixJQUFJLENBQUM2VCxPQUFPLENBQUN2QztZQUViLDhEQUE4RDtZQUM5RCw4Q0FBOEM7WUFDOUMsbUVBQW1FO1lBQ25FLGdDQUFnQztZQUNoQyxJQUFJaU0sMkJBQTJCLElBQUksQ0FBQ2xaLFFBQVEsRUFBRTtnQkFDN0MsSUFBSSxDQUFDQSxRQUFRLENBQUNvRSxNQUFNLENBQUN5VSxlQUFlLENBQUMsSUFBSTtZQUMxQztZQUVBLE9BQU8sSUFBSTtRQUNaO0lBQ0Q7SUFFQTdkLFNBQVFPLGtCQUFrQixHQUFHQTtJQUM3QlAsU0FBUTRELGFBQWEsR0FBR0E7SUFFeEJ1YSxPQUFPQyxjQUFjLENBQUNwZSxVQUFTLGNBQWM7UUFBRXFlLE9BQU87SUFBSztBQUU1RCxJQUNBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcz8wODI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBMZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgMS41LjMrbWFzdGVyLmU1MTI0YjIsXG4gKiBQcm92aWRlcyBCZWF1dGlmdWwgQW5pbWF0ZWQgTWFya2VyIENsdXN0ZXJpbmcgZnVuY3Rpb25hbGl0eSBmb3IgTGVhZmxldCwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC5tYXJrZXJjbHVzdGVyXG4gKiAoYykgMjAxMi0yMDE3LCBEYXZlIExlYXZlciwgc21hcnRyYWtcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoKGdsb2JhbC5MZWFmbGV0ID0gZ2xvYmFsLkxlYWZsZXQgfHwge30sIGdsb2JhbC5MZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgPSB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qXG5cdCAqIEwuTWFya2VyQ2x1c3Rlckdyb3VwIGV4dGVuZHMgTC5GZWF0dXJlR3JvdXAgYnkgY2x1c3RlcmluZyB0aGUgbWFya2VycyBjb250YWluZWQgd2l0aGluXG5cdCAqL1xuXG5cdHZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XG5cblx0XHRvcHRpb25zOiB7XG5cdFx0XHRtYXhDbHVzdGVyUmFkaXVzOiA4MCwgLy9BIGNsdXN0ZXIgd2lsbCBjb3ZlciBhdCBtb3N0IHRoaXMgbWFueSBwaXhlbHMgZnJvbSBpdHMgY2VudGVyXG5cdFx0XHRpY29uQ3JlYXRlRnVuY3Rpb246IG51bGwsXG5cdFx0XHRjbHVzdGVyUGFuZTogTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMucGFuZSxcblxuXHRcdFx0c3BpZGVyZnlPbkV2ZXJ5Wm9vbTogZmFsc2UsXG5cdFx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogdHJ1ZSxcblx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXI6IHRydWUsXG5cdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrOiB0cnVlLFxuXHRcdFx0c2luZ2xlTWFya2VyTW9kZTogZmFsc2UsXG5cblx0XHRcdGRpc2FibGVDbHVzdGVyaW5nQXRab29tOiBudWxsLFxuXG5cdFx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcblx0XHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblx0XHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxuXG5cdFx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhbGwgYW5pbWF0aW9ucyAoem9vbSBhbmQgc3BpZGVyZnkpLlxuXHRcdFx0Ly8gSWYgZmFsc2UsIG9wdGlvbiBhbmltYXRlQWRkaW5nTWFya2VycyBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0Ly8gSWYgTC5Eb21VdGlsLlRSQU5TSVRJT04gaXMgZmFsc3ksIHRoaXMgb3B0aW9uIGhhcyBubyBlZmZlY3QuXG5cdFx0XHRhbmltYXRlOiB0cnVlLFxuXG5cdFx0XHQvL1doZXRoZXIgdG8gYW5pbWF0ZSBhZGRpbmcgbWFya2VycyBhZnRlciBhZGRpbmcgdGhlIE1hcmtlckNsdXN0ZXJHcm91cCB0byB0aGUgbWFwXG5cdFx0XHQvLyBJZiB5b3UgYXJlIGFkZGluZyBpbmRpdmlkdWFsIG1hcmtlcnMgc2V0IHRvIHRydWUsIGlmIGFkZGluZyBidWxrIG1hcmtlcnMgbGVhdmUgZmFsc2UgZm9yIG1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMuXG5cdFx0XHRhbmltYXRlQWRkaW5nTWFya2VyczogZmFsc2UsXG5cblx0XHRcdC8vIE1ha2UgaXQgcG9zc2libGUgdG8gcHJvdmlkZSBjdXN0b20gZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHNwaWRlcmZ5IHNoYXBlIHBvc2l0aW9uc1xuXHRcdFx0c3BpZGVyZnlTaGFwZVBvc2l0aW9uczogbnVsbCxcblxuXHRcdFx0Ly9JbmNyZWFzZSB0byBpbmNyZWFzZSB0aGUgZGlzdGFuY2UgYXdheSB0aGF0IHNwaWRlcmZpZWQgbWFya2VycyBhcHBlYXIgZnJvbSB0aGUgY2VudGVyXG5cdFx0XHRzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllcjogMSxcblxuXHRcdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcblx0XHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXG5cblx0XHRcdC8vIFdoZW4gYnVsayBhZGRpbmcgbGF5ZXJzLCBhZGRzIG1hcmtlcnMgaW4gY2h1bmtzLiBNZWFucyBhZGRMYXllcnMgbWF5IG5vdCBhZGQgYWxsIHRoZSBsYXllcnMgaW4gdGhlIGNhbGwsIG90aGVycyB3aWxsIGJlIGxvYWRlZCBkdXJpbmcgc2V0VGltZW91dHNcblx0XHRcdGNodW5rZWRMb2FkaW5nOiBmYWxzZSxcblx0XHRcdGNodW5rSW50ZXJ2YWw6IDIwMCwgLy8gcHJvY2VzcyBtYXJrZXJzIGZvciBhIG1heGltdW0gb2YgfiBuIG1pbGxpc2Vjb25kcyAodGhlbiB0cmlnZ2VyIHRoZSBjaHVua1Byb2dyZXNzIGNhbGxiYWNrKVxuXHRcdFx0Y2h1bmtEZWxheTogNTAsIC8vIGF0IHRoZSBlbmQgb2YgZWFjaCBpbnRlcnZhbCwgZ2l2ZSBuIG1pbGxpc2Vjb25kcyBiYWNrIHRvIHN5c3RlbS9icm93c2VyXG5cdFx0XHRjaHVua1Byb2dyZXNzOiBudWxsLCAvLyBwcm9ncmVzcyBjYWxsYmFjazogZnVuY3Rpb24ocHJvY2Vzc2VkLCB0b3RhbCwgZWxhcHNlZCkgKGUuZy4gZm9yIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yKVxuXG5cdFx0XHQvL09wdGlvbnMgdG8gcGFzcyB0byB0aGUgTC5Qb2x5Z29uIGNvbnN0cnVjdG9yXG5cdFx0XHRwb2x5Z29uT3B0aW9uczoge31cblx0XHR9LFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwID0gTC5mZWF0dXJlR3JvdXAoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XG5cblx0XHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXG5cdFx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xuXG5cdFx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMgPSB7XG5cdFx0XHRcdCdkcmFnc3RhcnQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdTdGFydCxcblx0XHRcdFx0J21vdmUnOiB0aGlzLl9jaGlsZE1hcmtlck1vdmVkLFxuXHRcdFx0XHQnZHJhZ2VuZCc6IHRoaXMuX2NoaWxkTWFya2VyRHJhZ0VuZCxcblx0XHRcdH07XG5cblx0XHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxuXHRcdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcblx0XHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xuXHRcdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cblx0XHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XG5cdFx0fSxcblxuXHRcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZExheWVycyhbbGF5ZXJdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXG5cdFx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xuXHRcdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nLnB1c2gobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly9JZiB3ZSBoYXZlIGFscmVhZHkgY2x1c3RlcmVkIHdlJ2xsIG5lZWQgdG8gYWRkIHRoaXMgb25lIHRvIGEgY2x1c3RlclxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcblxuXHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcblx0XHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcblx0XHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XG5cdFx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcblx0XHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xuXHRcdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHZpc2libGVMYXllci5nZXRMYXRMbmcoKSkpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5hbmltYXRlQWRkaW5nTWFya2Vycykge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyKGxheWVyLCB2aXNpYmxlTGF5ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIHZpc2libGVMYXllcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vTm9uIHBvaW50IGxheWVyc1xuXHRcdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcblx0XHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmVMYXllcihsYXllcik7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBsYXllcikgJiYgdGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbGF5ZXIsIGxhdGxuZzogbGF5ZXIuX2xhdGxuZyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBjbHVzdGVyc1xuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobGF5ZXIsIHRydWUpO1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXG5cdFx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xuXG5cdFx0XHRsYXllci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCBhZGRzIHRoZW0gaW4gYnVsa1xuXHRcdGFkZExheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5LCBza2lwTGF5ZXJBZGRFdmVudCkge1xuXHRcdFx0aWYgKCFMLlV0aWwuaXNBcnJheShsYXllcnNBcnJheSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXJzQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcblx0XHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxuXHRcdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcblx0XHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXG5cdFx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcblx0XHRcdCAgICBvZmZzZXQgPSAwLFxuXHRcdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxuXHRcdFx0ICAgIG07XG5cblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dmFyIHN0YXJ0ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHR2YXIgcHJvY2VzcyA9IEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0byB1bnNwaWRlcmZ5IGJlZm9yZSBzdGFydGluZyB0byBhZGQgc29tZSBsYXllcnNcblx0XHRcdFx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX3Vuc3BpZGVyZnkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcblx0XHRcdFx0XHRcdGlmIChjaHVua2VkICYmIG9mZnNldCAlIDIwMCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBldmVyeSBjb3VwbGUgaHVuZHJlZCBtYXJrZXJzLCBpbnN0cnVtZW50IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgcHJvY2Vzc2luZyBzdGFydGVkOlxuXHRcdFx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBjaHVua0ludGVydmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7IC8vIGJlZW4gd29ya2luZyB0b28gaGFyZCwgdGltZSB0byB0YWtlIGEgYnJlYWsgOi0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XG5cblx0XHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxuXHRcdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXG5cdFx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxuXHRcdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxuXHRcdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcblx0XHRcdFx0XHRcdGlmICghbS5nZXRMYXRMbmcpIHtcblx0XHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXNraXBMYXllckFkZEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vSWYgd2UganVzdCBtYWRlIGEgY2x1c3RlciBvZiBzaXplIDIgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgb3RoZXIgbWFya2VyIGZyb20gdGhlIG1hcCAoaWYgaXQgaXMpIG9yIHdlIG5ldmVyIHdpbGxcblx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJzID0gbS5fX3BhcmVudC5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0XHRcdFx0XHQgICAgb3RoZXJNYXJrZXIgPSBtYXJrZXJzWzBdID09PSBtID8gbWFya2Vyc1sxXSA6IG1hcmtlcnNbMF07XG5cdFx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIob3RoZXJNYXJrZXIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNodW5rUHJvZ3Jlc3MpIHtcblx0XHRcdFx0XHRcdC8vIHJlcG9ydCBwcm9ncmVzcyBhbmQgdGltZSBlbGFwc2VkOlxuXHRcdFx0XHRcdFx0Y2h1bmtQcm9ncmVzcyhvZmZzZXQsIGwsIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydGVkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cblx0XHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5lZWRzQ2x1c3RlcmluZyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblxuXHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbb2Zmc2V0XTtcblxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9Ob3QgcG9pbnQgZGF0YSwgY2FuJ3QgYmUgY2x1c3RlcmVkXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xuXHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCByZW1vdmVzIHRoZW0gaW4gYnVsa1xuXHRcdHJlbW92ZUxheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5KSB7XG5cdFx0XHR2YXIgaSwgbSxcblx0XHRcdCAgICBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoLFxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0ICAgIG5wZyA9IHRoaXMuX25vblBvaW50R3JvdXAsXG5cdFx0XHQgICAgb3JpZ2luYWxBcnJheSA9IHRydWU7XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xuXHRcdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbSk7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbSwgbGF0bG5nOiBtLl9sYXRsbmcgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cblx0XHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXG5cdFx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxuXHRcdFx0XHQgICAgbDIgPSBsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5Mik7XG5cdFx0XHRcdFx0XHRsMiA9IGxheWVyc0FycmF5Mi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5TGF5ZXIobSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXG5cdFx0XHRcdGlmIChmZy5oYXNMYXllcihtKSkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdC8vRml4IHVwIHRoZSBjbHVzdGVycyBhbmQgbWFya2VycyBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXG5cdFx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcblxuXHRcdFx0Ly9JZiB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCAoeWV0KSwgYmxvdyBhd2F5IHRoZSBtYXJrZXJzIHdlIGtub3cgb2Zcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkpIHtcblx0XHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHRcdG1hcmtlci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblx0XHRcdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdC8vUmVzZXQgX3RvcENsdXN0ZXJMZXZlbCBhbmQgdGhlIERpc3RhbmNlR3JpZHNcblx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgRmVhdHVyZUdyb3VwLmdldEJvdW5kcyBhcyBpdCBkb2Vzbid0IHdvcmtcblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYm91bmRzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbm9uUG9pbnRHcm91cC5nZXRCb3VuZHMoKSk7XG5cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZWFjaExheWVyXG5cdFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5zbGljZSgpLFxuXHRcdFx0XHRuZWVkc1JlbW92aW5nID0gdGhpcy5fbmVlZHNSZW1vdmluZyxcblx0XHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcsIGksIGo7XG5cblx0XHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycyhtYXJrZXJzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IHRydWU7XG5cblx0XHRcdFx0Zm9yIChqID0gbmVlZHNSZW1vdmluZy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdGlmIChuZWVkc1JlbW92aW5nW2pdLmxheWVyID09PSBtYXJrZXJzW2ldKSB7XG5cdFx0XHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXNOZWVkc1JlbW92aW5nKSB7XG5cdFx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5lYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KTtcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllcnNcblx0XHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsYXllcnMgPSBbXTtcblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRcdGxheWVycy5wdXNoKGwpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbGF5ZXJzO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyLCBXQVJOSU5HOiBSZWFsbHkgYmFkIHBlcmZvcm1hbmNlXG5cdFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHRcdGlkID0gcGFyc2VJbnQoaWQsIDEwKTtcblxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcblx0XHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBsYXllciBpcyBpbiB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cFxuXHRcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaSwgYW5BcnJheSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblxuXHRcdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhbkFycmF5ID0gdGhpcy5fbmVlZHNSZW1vdmluZztcblx0XHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0ubGF5ZXIgPT09IGxheWVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAhIShsYXllci5fX3BhcmVudCAmJiBsYXllci5fX3BhcmVudC5fZ3JvdXAgPT09IHRoaXMpIHx8IHRoaXMuX25vblBvaW50R3JvdXAuaGFzTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHQvL1pvb20gZG93biB0byBzaG93IHRoZSBnaXZlbiBsYXllciAoc3BpZGVyZnlpbmcgaWYgbmVjZXNzYXJ5KSB0aGVuIGNhbGxzIHRoZSBjYWxsYmFja1xuXHRcdHpvb21Ub1Nob3dMYXllcjogZnVuY3Rpb24gKGxheWVyLCBjYWxsYmFjaykge1xuXG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaG93TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgbWFwLmhhc0xheWVyIGNoZWNrcyBmb3IgZGlyZWN0IGFwcGVhcmFuY2Ugb24gbWFwLCBub3QgcmVjdXJzaXZlbHkgY2FsbGluZ1xuXHRcdFx0XHQvLyBoYXNMYXllciBvbiBMYXllciBHcm91cHMgdGhhdCBhcmUgb24gbWFwICh0eXBpY2FsbHkgbm90IGNhbGxpbmcgdGhpcyBNYXJrZXJDbHVzdGVyR3JvdXAuaGFzTGF5ZXIsIHdoaWNoIHdvdWxkIGFsd2F5cyByZXR1cm4gdHJ1ZSlcblx0XHRcdFx0aWYgKChtYXAuaGFzTGF5ZXIobGF5ZXIpIHx8IG1hcC5oYXNMYXllcihsYXllci5fX3BhcmVudCkpICYmICF0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hcC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5faWNvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5vbmNlKCdzcGlkZXJmaWVkJywgY2FsbGJhY2ssIHRoaXMpO1xuXHRcdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XG5cdFx0XHRcdC8vTGF5ZXIgaXMgdmlzaWJsZSBvbmQgb24gc2NyZWVuLCBpbW1lZGlhdGUgcmV0dXJuXG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll96b29tIDwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pKSB7XG5cdFx0XHRcdC8vTGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgdGhpcyB6b29tIGxldmVsLiBJdCBtdXN0IG5vdCBiZSBvbiBzY3JlZW4gc28ganVzdCBwYW4gb3ZlciB0byBpdFxuXHRcdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5fbWFwLnBhblRvKGxheWVyLmdldExhdExuZygpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9uKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuem9vbVRvQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vbkFkZFxuXHRcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0XHR2YXIgaSwgbCwgbGF5ZXI7XG5cblx0XHRcdGlmICghaXNGaW5pdGUodGhpcy5fbWFwLmdldE1heFpvb20oKSkpIHtcblx0XHRcdFx0dGhyb3cgXCJNYXAgaGFzIG5vIG1heFpvb20gc3BlY2lmaWVkXCI7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRUbyhtYXApO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2dyaWRDbHVzdGVycykge1xuXHRcdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tYXhMYXQgPSBtYXAub3B0aW9ucy5jcnMucHJvamVjdGlvbi5NQVhfTEFUSVRVREU7XG5cblx0XHRcdC8vUmVzdG9yZSBhbGwgdGhlIHBvc2l0aW9ucyBhcyB0aGV5IGFyZSBpbiB0aGUgTUNHIGJlZm9yZSByZW1vdmluZyB0aGVtXG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xuXHRcdFx0XHRsYXllci5uZXdsYXRsbmcgPSBsYXllci5sYXllci5fbGF0bG5nO1xuXHRcdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubGF0bG5nO1xuXHRcdFx0fVxuXHRcdFx0Ly9SZW1vdmUgdGhlbSwgdGhlbiByZXN0b3JlIHRoZWlyIG5ldyBwb3NpdGlvbnNcblx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLmxheWVyLCB0cnVlKTtcblx0XHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLm5ld2xhdGxuZztcblx0XHRcdH1cblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcblxuXHRcdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcblx0XHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25BZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0FjdHVhbGx5IGFkZCBvdXIgbWFya2VycyB0byB0aGUgbWFwOlxuXHRcdFx0bCA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0dGhpcy5hZGRMYXllcnMobCwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxuXHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX3VuYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0luIGNhc2Ugd2UgYXJlIGluIGEgY2x1c3RlciBhbmltYXRpb25cblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIHRoaXMuX21heExhdDtcblxuXHRcdFx0Ly9DbGVhbiB1cCBhbGwgdGhlIGxheWVycyB3ZSBhZGRlZCB0byB0aGUgbWFwXG5cdFx0XHR0aGlzLl9oaWRlQ292ZXJhZ2UoKTtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAucmVtb3ZlKCk7XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLl9tYXAgPSBudWxsO1xuXHRcdH0sXG5cblx0XHRnZXRWaXNpYmxlUGFyZW50OiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHR2YXIgdk1hcmtlciA9IG1hcmtlcjtcblx0XHRcdHdoaWxlICh2TWFya2VyICYmICF2TWFya2VyLl9pY29uKSB7XG5cdFx0XHRcdHZNYXJrZXIgPSB2TWFya2VyLl9fcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZNYXJrZXIgfHwgbnVsbDtcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmUgdGhlIGdpdmVuIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheVxuXHRcdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IG9iaikge1xuXHRcdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSBhbGwgX2dyaWRVbmNsdXN0ZXJlZCB6b29tIGxldmVscywgc3RhcnRpbmcgYXQgdGhlIHN1cHBsaWVkIHpvb20uXG5cdFx0ICogQHBhcmFtIG1hcmtlciB0byBiZSByZW1vdmVkIGZyb20gX2dyaWRVbmNsdXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0geiBpbnRlZ2VyIGJvdHRvbSBzdGFydCB6b29tIGxldmVsIChpbmNsdWRlZClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkOiBmdW5jdGlvbiAobWFya2VyLCB6KSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XG5cblx0XHRcdGZvciAoOyB6ID49IG1pblpvb207IHotLSkge1xuXHRcdFx0XHRpZiAoIWdyaWRVbmNsdXN0ZXJlZFt6XS5yZW1vdmVPYmplY3QobWFya2VyLCBtYXAucHJvamVjdChtYXJrZXIuZ2V0TGF0TG5nKCksIHopKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jaGlsZE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX2xhdGxuZztcblx0XHR9LFxuXG5cdFx0X2NoaWxkTWFya2VyTW92ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2lnbm9yZU1vdmUgJiYgIWUudGFyZ2V0Ll9fZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdHZhciBpc1BvcHVwT3BlbiA9IGUudGFyZ2V0Ll9wb3B1cCAmJiBlLnRhcmdldC5fcG9wdXAuaXNPcGVuKCk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZUNoaWxkKGUudGFyZ2V0LCBlLm9sZExhdExuZywgZS5sYXRsbmcpO1xuXG5cdFx0XHRcdGlmIChpc1BvcHVwT3Blbikge1xuXHRcdFx0XHRcdGUudGFyZ2V0Lm9wZW5Qb3B1cCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9tb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChsYXllciwgZnJvbSwgdG8pIHtcblx0XHRcdGxheWVyLl9sYXRsbmcgPSBmcm9tO1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XG5cblx0XHRcdGxheWVyLl9sYXRsbmcgPSB0bztcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHRfY2hpbGRNYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGRyYWdTdGFydCA9IGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0ZGVsZXRlIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0aWYgKGRyYWdTdGFydCkge1xuXHRcdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGRyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblxuXHRcdC8vSW50ZXJuYWwgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgbWFya2VyIGZyb20gZXZlcnl0aGluZy5cblx0XHQvL2RvbnRVcGRhdGVNYXA6IHNldCB0byB0cnVlIGlmIHlvdSB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGUgbWFwIG1hbnVhbGx5IChmb3IgYnVsayBmdW5jdGlvbnMpXG5cdFx0X3JlbW92ZUxheWVyOiBmdW5jdGlvbiAobWFya2VyLCByZW1vdmVGcm9tRGlzdGFuY2VHcmlkLCBkb250VXBkYXRlTWFwKSB7XG5cdFx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXG5cdFx0XHRcdGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xuXG5cdFx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gZGlzdGFuY2UgY2x1c3RlcnMgaXQgbWlnaHQgYmUgaW5cblx0XHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQobWFya2VyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Xb3JrIG91ciB3YXkgdXAgdGhlIGNsdXN0ZXJzIHJlbW92aW5nIHRoZW0gYXMgd2UgZ28gaWYgcmVxdWlyZWRcblx0XHRcdHZhciBjbHVzdGVyID0gbWFya2VyLl9fcGFyZW50LFxuXHRcdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2Vycyxcblx0XHRcdFx0b3RoZXJNYXJrZXI7XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgaW1tZWRpYXRlIHBhcmVudHMgbWFya2VyIGxpc3Rcblx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKG1hcmtlcnMsIG1hcmtlcik7XG5cblx0XHRcdHdoaWxlIChjbHVzdGVyKSB7XG5cdFx0XHRcdGNsdXN0ZXIuX2NoaWxkQ291bnQtLTtcblx0XHRcdFx0Y2x1c3Rlci5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGNsdXN0ZXIuX3pvb20gPCBtaW5ab29tKSB7XG5cdFx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkICYmIGNsdXN0ZXIuX2NoaWxkQ291bnQgPD0gMSkgeyAvL0NsdXN0ZXIgbm8gbG9uZ2VyIHJlcXVpcmVkXG5cdFx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIgPSBjbHVzdGVyLl9tYXJrZXJzWzBdID09PSBtYXJrZXIgPyBjbHVzdGVyLl9tYXJrZXJzWzFdIDogY2x1c3Rlci5fbWFya2Vyc1swXTtcblxuXHRcdFx0XHRcdC8vVXBkYXRlIGRpc3RhbmNlIGdyaWRcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbY2x1c3Rlci5fem9vbV0ucmVtb3ZlT2JqZWN0KGNsdXN0ZXIsIG1hcC5wcm9qZWN0KGNsdXN0ZXIuX2NMYXRMbmcsIGNsdXN0ZXIuX3pvb20pKTtcblx0XHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbY2x1c3Rlci5fem9vbV0uYWRkT2JqZWN0KG90aGVyTWFya2VyLCBtYXAucHJvamVjdChvdGhlck1hcmtlci5nZXRMYXRMbmcoKSwgY2x1c3Rlci5fem9vbSkpO1xuXG5cdFx0XHRcdFx0Ly9Nb3ZlIG90aGVyTWFya2VyIHVwIHRvIHBhcmVudFxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xuXHRcdFx0XHRcdGNsdXN0ZXIuX19wYXJlbnQuX21hcmtlcnMucHVzaChvdGhlck1hcmtlcik7XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIuX19wYXJlbnQgPSBjbHVzdGVyLl9fcGFyZW50O1xuXG5cdFx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcblx0XHRcdFx0XHRcdC8vQ2x1c3RlciBpcyBjdXJyZW50bHkgb24gdGhlIG1hcCwgbmVlZCB0byBwdXQgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGluc3RlYWRcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGNsdXN0ZXIpO1xuXHRcdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XG5cdFx0XHRcdFx0XHRcdGZnLmFkZExheWVyKG90aGVyTWFya2VyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2x1c3Rlci5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsdXN0ZXIgPSBjbHVzdGVyLl9fcGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xuXHRcdH0sXG5cblx0XHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xuXHRcdFx0d2hpbGUgKG9lbCkge1xuXHRcdFx0XHRpZiAoZWwgPT09IG9lbCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9lbCA9IG9lbC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlIEwuRXZlbnRlZC5maXJlXG5cdFx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5sYXllciBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHQvL1ByZXZlbnQgbXVsdGlwbGUgY2x1c3Rlcm1vdXNlb3Zlci9vZmYgZXZlbnRzIGlmIHRoZSBpY29uIGlzIG1hZGUgdXAgb2Ygc3RhY2tlZCBkaXZzIChEb2Vzbid0IHdvcmsgaW4gaWUgPD0gOCwgbm8gcmVsYXRlZFRhcmdldClcblx0XHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudCAmJiB0aGlzLl9pc09ySXNQYXJlbnQoZGF0YS5sYXllci5faWNvbiwgZGF0YS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR5cGUgPSAnY2x1c3RlcicgKyB0eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuZmlyZS5jYWxsKHRoaXMsIHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmxpc3RlbnNcblx0XHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XG5cdFx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCB0eXBlLCBwcm9wYWdhdGUpIHx8IEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgJ2NsdXN0ZXInICsgdHlwZSwgcHJvcGFnYXRlKTtcblx0XHR9LFxuXG5cdFx0Ly9EZWZhdWx0IGZ1bmN0aW9uYWxpdHlcblx0XHRfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcblx0XHRcdHZhciBjaGlsZENvdW50ID0gY2x1c3Rlci5nZXRDaGlsZENvdW50KCk7XG5cblx0XHRcdHZhciBjID0gJyBtYXJrZXItY2x1c3Rlci0nO1xuXHRcdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xuXHRcdFx0XHRjICs9ICdzbWFsbCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkQ291bnQgPCAxMDApIHtcblx0XHRcdFx0YyArPSAnbWVkaXVtJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGMgKz0gJ2xhcmdlJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBMLkRpdkljb24oeyBodG1sOiAnPGRpdj48c3Bhbj4nICsgY2hpbGRDb3VudCArICc8L3NwYW4+PC9kaXY+JywgY2xhc3NOYW1lOiAnbWFya2VyLWNsdXN0ZXInICsgYywgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCkgfSk7XG5cdFx0fSxcblxuXHRcdF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0ICAgIHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3Zlcixcblx0XHRcdCAgICB6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2ssXG5cdFx0XHQgICAgc3BpZGVyZnlPbkV2ZXJ5Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tO1xuXG5cdFx0XHQvL1pvb20gb24gY2x1c3RlciBjbGljayBvciBzcGlkZXJmeSBpZiB3ZSBhcmUgYXQgdGhlIGxvd2VzdCBsZXZlbFxuXHRcdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2sgfHwgc3BpZGVyZnlPbkV2ZXJ5Wm9vbSkge1xuXHRcdFx0XHR0aGlzLm9uKCdjbHVzdGVyY2xpY2sgY2x1c3RlcmtleXByZXNzJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1Nob3cgY29udmV4IGh1bGwgKGJvdW5kYXJ5KSBwb2x5Z29uIG9uIG1vdXNlIG92ZXJcblx0XHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW92ZXInLCB0aGlzLl9zaG93Q292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfem9vbU9yU3BpZGVyZnk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgY2x1c3RlciA9IGUubGF5ZXIsXG5cdFx0XHQgICAgYm90dG9tQ2x1c3RlciA9IGNsdXN0ZXI7XG5cblx0XHRcdGlmIChlLnR5cGUgPT09ICdjbHVzdGVya2V5cHJlc3MnICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSAhPT0gMTMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Ym90dG9tQ2x1c3RlciA9IGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnNbMF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3R0b21DbHVzdGVyLl96b29tID09PSB0aGlzLl9tYXhab29tICYmXG5cdFx0XHRcdGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IGNsdXN0ZXIuX2NoaWxkQ291bnQgJiZcblx0XHRcdFx0dGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tKSB7XG5cblx0XHRcdFx0Ly8gQWxsIGNoaWxkIG1hcmtlcnMgYXJlIGNvbnRhaW5lZCBpbiBhIHNpbmdsZSBjbHVzdGVyIGZyb20gdGhpcy5fbWF4Wm9vbSB0byB0aGlzIGNsdXN0ZXIuXG5cdFx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2spIHtcblx0XHRcdFx0Y2x1c3Rlci56b29tVG9Cb3VuZHMoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tKSB7XG5cdFx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9jdXMgdGhlIG1hcCBhZ2FpbiBmb3Iga2V5Ym9hcmQgdXNlcnMuXG5cdFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xuXHRcdFx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2hvd0NvdmVyYWdlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdH1cblx0XHRcdGlmIChlLmxheWVyLmdldENoaWxkQ291bnQoKSA+IDIgJiYgZS5sYXllciAhPT0gdGhpcy5fc3BpZGVyZmllZCkge1xuXHRcdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBuZXcgTC5Qb2x5Z29uKGUubGF5ZXIuZ2V0Q29udmV4SHVsbCgpLCB0aGlzLm9wdGlvbnMucG9seWdvbk9wdGlvbnMpO1xuXHRcdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpZGVDb3ZlcmFnZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3VuYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0XHRzaG93Q292ZXJhZ2VPbkhvdmVyID0gdGhpcy5vcHRpb25zLnNob3dDb3ZlcmFnZU9uSG92ZXIsXG5cdFx0XHRcdHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljayxcblx0XHRcdFx0c3BpZGVyZnlPbkV2ZXJ5Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tLFxuXHRcdFx0XHRtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdGlmIChzcGlkZXJmeU9uTWF4Wm9vbSB8fCB6b29tVG9Cb3VuZHNPbkNsaWNrIHx8IHNwaWRlcmZ5T25FdmVyeVpvb20pIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJjbGljayBjbHVzdGVya2V5cHJlc3MnLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvd0NvdmVyYWdlT25Ib3Zlcikge1xuXHRcdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3pvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tZXJnZVNwbGl0Q2x1c3RlcnMoKTtcblxuXHRcdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXHRcdH0sXG5cblx0XHRfbW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdCb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIG5ld0JvdW5kcyk7XG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSksIG5ld0JvdW5kcyk7XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IG5ld0JvdW5kcztcblx0XHRcdHJldHVybjtcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWF4Wm9vbSA9IE1hdGguY2VpbCh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMub3B0aW9ucy5tYXhDbHVzdGVyUmFkaXVzLFxuXHRcdFx0XHRyYWRpdXNGbiA9IHJhZGl1cztcblxuXHRcdFx0Ly9JZiB3ZSBqdXN0IHNldCBtYXhDbHVzdGVyUmFkaXVzIHRvIGEgc2luZ2xlIG51bWJlciwgd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdC8vYSBzaW1wbGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRoYXQgbnVtYmVyLiBPdGhlcndpc2UsIHdlIGp1c3QgaGF2ZSB0b1xuXHRcdFx0Ly91c2UgdGhlIGZ1bmN0aW9uIHdlJ3ZlIHBhc3NlZCBpbi5cblx0XHRcdGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmFkaXVzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByYWRpdXM7IH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gIT09IG51bGwpIHtcblx0XHRcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAtIDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tYXhab29tID0gbWF4Wm9vbTtcblx0XHRcdHRoaXMuX2dyaWRDbHVzdGVycyA9IHt9O1xuXHRcdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkID0ge307XG5cblx0XHRcdC8vU2V0IHVwIERpc3RhbmNlR3JpZHMgZm9yIGVhY2ggem9vbVxuXHRcdFx0Zm9yICh2YXIgem9vbSA9IG1heFpvb207IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XG5cdFx0XHRcdHRoaXMuX2dyaWRDbHVzdGVyc1t6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XG5cdFx0XHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZFt6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBMLk1hcmtlckNsdXN0ZXIgY2xhc3MgKGFuaW1hdGVkIG9yIG5vdCkuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCBtaW5ab29tIC0gMSk7XG5cdFx0fSxcblxuXHRcdC8vWm9vbTogWm9vbSB0byBzdGFydCBhZGRpbmcgYXQgKFBhc3MgdGhpcy5fbWF4Wm9vbSB0byBzdGFydCBhdCB0aGUgYm90dG9tKVxuXHRcdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCB6b29tKSB7XG5cdFx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXG5cdFx0XHQgICAgbWFya2VyUG9pbnQsIHo7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xuXHRcdFx0XHR0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5vbih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xuXG5cdFx0XHQvL0ZpbmQgdGhlIGxvd2VzdCB6b29tIGxldmVsIHRvIHNsb3QgdGhpcyBvbmUgaW5cblx0XHRcdGZvciAoOyB6b29tID49IG1pblpvb207IHpvb20tLSkge1xuXHRcdFx0XHRtYXJrZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxheWVyLmdldExhdExuZygpLCB6b29tKTsgLy8gY2FsY3VsYXRlIHBpeGVsIHBvc2l0aW9uXG5cblx0XHRcdFx0Ly9UcnkgZmluZCBhIGNsdXN0ZXIgY2xvc2UgYnlcblx0XHRcdFx0dmFyIGNsb3Nlc3QgPSBncmlkQ2x1c3RlcnNbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XG5cdFx0XHRcdGlmIChjbG9zZXN0KSB7XG5cdFx0XHRcdFx0Y2xvc2VzdC5fYWRkQ2hpbGQobGF5ZXIpO1xuXHRcdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gY2xvc2VzdDtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1RyeSBmaW5kIGEgbWFya2VyIGNsb3NlIGJ5IHRvIGZvcm0gYSBuZXcgY2x1c3RlciB3aXRoXG5cdFx0XHRcdGNsb3Nlc3QgPSBncmlkVW5jbHVzdGVyZWRbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XG5cdFx0XHRcdGlmIChjbG9zZXN0KSB7XG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IGNsb3Nlc3QuX19wYXJlbnQ7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIoY2xvc2VzdCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vQ3JlYXRlIG5ldyBjbHVzdGVyIHdpdGggdGhlc2UgMiBpbiBpdFxuXG5cdFx0XHRcdFx0dmFyIG5ld0NsdXN0ZXIgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCB6b29tLCBjbG9zZXN0LCBsYXllcik7XG5cdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pvb21dLmFkZE9iamVjdChuZXdDbHVzdGVyLCB0aGlzLl9tYXAucHJvamVjdChuZXdDbHVzdGVyLl9jTGF0TG5nLCB6b29tKSk7XG5cdFx0XHRcdFx0Y2xvc2VzdC5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XG5cdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xuXG5cdFx0XHRcdFx0Ly9GaXJzdCBjcmVhdGUgYW55IG5ldyBpbnRlcm1lZGlhdGUgcGFyZW50IGNsdXN0ZXJzIHRoYXQgZG9uJ3QgZXhpc3Rcblx0XHRcdFx0XHR2YXIgbGFzdFBhcmVudCA9IG5ld0NsdXN0ZXI7XG5cdFx0XHRcdFx0Zm9yICh6ID0gem9vbSAtIDE7IHogPiBwYXJlbnQuX3pvb207IHotLSkge1xuXHRcdFx0XHRcdFx0bGFzdFBhcmVudCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHosIGxhc3RQYXJlbnQpO1xuXHRcdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pdLmFkZE9iamVjdChsYXN0UGFyZW50LCB0aGlzLl9tYXAucHJvamVjdChjbG9zZXN0LmdldExhdExuZygpLCB6KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudC5fYWRkQ2hpbGQobGFzdFBhcmVudCk7XG5cblx0XHRcdFx0XHQvL1JlbW92ZSBjbG9zZXN0IGZyb20gdGhpcyB6b29tIGxldmVsIGFuZCBhbnkgYWJvdmUgdGhhdCBpdCBpcyBpbiwgcmVwbGFjZSB3aXRoIG5ld0NsdXN0ZXJcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkKGNsb3Nlc3QsIHpvb20pO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9EaWRuJ3QgbWFuYWdlIHRvIGNsdXN0ZXIgaW4gYXQgdGhpcyB6b29tLCByZWNvcmQgdXMgYXMgYSBtYXJrZXIgaGVyZSBhbmQgY29udGludWUgdXB3YXJkc1xuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbem9vbV0uYWRkT2JqZWN0KGxheWVyLCBtYXJrZXJQb2ludCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vRGlkbid0IGdldCBpbiBhbnl0aGluZywgYWRkIHVzIHRvIHRoZSB0b3Bcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYWRkQ2hpbGQobGF5ZXIpO1xuXHRcdFx0bGF5ZXIuX19wYXJlbnQgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZnJlc2hlcyB0aGUgaWNvbiBvZiBhbGwgXCJkaXJ0eVwiIHZpc2libGUgY2x1c3RlcnMuXG5cdFx0ICogTm9uLXZpc2libGUgXCJkaXJ0eVwiIGNsdXN0ZXJzIHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfcmVmcmVzaENsdXN0ZXJzSWNvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIgJiYgYy5faWNvbk5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdFx0Yy5fdXBkYXRlSWNvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly9FbnF1ZXVlIGNvZGUgdG8gZmlyZSBhZnRlciB0aGUgbWFya2VyIGV4cGFuZC9jb250cmFjdCBoYXMgaGFwcGVuZWRcblx0XHRfZW5xdWV1ZTogZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHR0aGlzLl9xdWV1ZS5wdXNoKGZuKTtcblx0XHRcdGlmICghdGhpcy5fcXVldWVUaW1lb3V0KSB7XG5cdFx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Byb2Nlc3NRdWV1ZSwgdGhpcyksIDMwMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3F1ZXVlW2ldLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3F1ZXVlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBudWxsO1xuXHRcdH0sXG5cblx0XHQvL01lcmdlIGFuZCBzcGxpdCBhbnkgZXhpc3RpbmcgY2x1c3RlcnMgdGhhdCBhcmUgdG9vIGJpZyBvciBzbWFsbFxuXHRcdF9tZXJnZVNwbGl0Q2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXBab29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xuXG5cdFx0XHQvL0luIGNhc2Ugd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZpbmlzaGVkXG5cdFx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3pvb20gPCBtYXBab29tICYmIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKSkgeyAvL1pvb20gaW4sIHNwbGl0XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cdFx0XHRcdC8vUmVtb3ZlIGNsdXN0ZXJzIG5vdyBvZmYgc2NyZWVuXG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCB0aGlzLl96b29tLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbUluKHRoaXMuX3pvb20sIG1hcFpvb20pO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3pvb20gPiBtYXBab29tKSB7IC8vWm9vbSBvdXQsIG1lcmdlXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dCh0aGlzLl96b29tLCBtYXBab29tKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21vdmVFbmQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9HZXRzIHRoZSBtYXBzIHZpc2libGUgYm91bmRzIGV4cGFuZGVkIGluIGVhY2ggZGlyZWN0aW9uIGJ5IHRoZSBzaXplIG9mIHRoZSBzY3JlZW4gKHNvIHRoZSB1c2VyIGNhbm5vdCBzZWUgYW4gYXJlYSB3ZSBkbyBub3QgY292ZXIgaW4gb25lIHBhbilcblx0XHRfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kcykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwQm91bmRzSW5maW5pdGU7XG5cdFx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci5tb2JpbGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkucGFkKDEpKTsgLy8gUGFkZGluZyBleHBhbmRzIHRoZSBib3VuZHMgYnkgaXRzIG93biBkaW1lbnNpb25zIGJ1dCBzY2FsZWQgd2l0aCB0aGUgZ2l2ZW4gZmFjdG9yLlxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHBhbmRzIHRoZSBsYXRpdHVkZSB0byBJbmZpbml0eSAob3IgLUluZmluaXR5KSBpZiB0aGUgaW5wdXQgYm91bmRzIHJlYWNoIHRoZSBtYXAgcHJvamVjdGlvbiBtYXhpbXVtIGRlZmluZWQgbGF0aXR1ZGVcblx0XHQgKiAoaW4gdGhlIGNhc2Ugb2YgV2ViL1NwaGVyaWNhbCBNZXJjYXRvciwgaXQgaXMgODUuMDUxMTI4Nzc5OCAvIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWVyY2F0b3IjRm9ybXVsYXMpLlxuXHRcdCAqIE90aGVyd2lzZSwgdGhlIHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIG9wdGlvbiB3aWxsIHJlbW92ZSBtYXJrZXJzIGJleW9uZCB0aGF0IGxpbWl0LCB3aGVyZWFzIHRoZSBzYW1lIG1hcmtlcnMgd2l0aG91dFxuXHRcdCAqIHRoaXMgb3B0aW9uIChvciBvdXRzaWRlIE1DRykgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9uIGZsb29yZWQgKGNlaWxlZCkgYnkgdGhlIHByb2plY3Rpb24gYW5kIHJlbmRlcmVkIGF0IHRoYXQgbGltaXQsXG5cdFx0ICogbWFraW5nIHRoZSB1c2VyIHRoaW5rIHRoYXQgTUNHIFwiZWF0c1wiIHRoZW0gYW5kIG5ldmVyIGRpc3BsYXlzIHRoZW0gYWdhaW4uXG5cdFx0ICogQHBhcmFtIGJvdW5kcyBMLkxhdExuZ0JvdW5kc1xuXHRcdCAqIEByZXR1cm5zIHtMLkxhdExuZ0JvdW5kc31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9jaGVja0JvdW5kc01heExhdDogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdFx0dmFyIG1heExhdCA9IHRoaXMuX21heExhdDtcblxuXHRcdFx0aWYgKG1heExhdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChib3VuZHMuZ2V0Tm9ydGgoKSA+PSBtYXhMYXQpIHtcblx0XHRcdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sYXQgPSBJbmZpbml0eTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYm91bmRzLmdldFNvdXRoKCkgPD0gLW1heExhdCkge1xuXHRcdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxhdCA9IC1JbmZpbml0eTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdH0sXG5cblx0XHQvL1NoYXJlZCBhbmltYXRpb24gY29kZVxuXHRcdF9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdGlmIChuZXdDbHVzdGVyID09PSBsYXllcikge1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID09PSAyKSB7XG5cdFx0XHRcdG5ld0NsdXN0ZXIuX2FkZFRvTWFwKCk7XG5cblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBuZXdDbHVzdGVyLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1swXSk7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzFdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdHMgaW5kaXZpZHVhbCAoaS5lLiBub24tZ3JvdXApIGxheWVycyBmcm9tIGEgTGF5ZXIgR3JvdXAuXG5cdFx0ICogQHBhcmFtIGdyb3VwIHRvIGV4dHJhY3QgbGF5ZXJzIGZyb20uXG5cdFx0ICogQHBhcmFtIG91dHB1dCB7QXJyYXl9IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBleHRyYWN0ZWQgbGF5ZXJzLlxuXHRcdCAqIEByZXR1cm5zIHsqfEFycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2V4dHJhY3ROb25Hcm91cExheWVyczogZnVuY3Rpb24gKGdyb3VwLCBvdXRwdXQpIHtcblx0XHRcdHZhciBsYXllcnMgPSBncm91cC5nZXRMYXllcnMoKSxcblx0XHRcdCAgICBpID0gMCxcblx0XHRcdCAgICBsYXllcjtcblxuXHRcdFx0b3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IGxheWVyc1tpXTtcblxuXHRcdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobGF5ZXIsIG91dHB1dCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEltcGxlbWVudHMgdGhlIHNpbmdsZU1hcmtlck1vZGUgb3B0aW9uLlxuXHRcdCAqIEBwYXJhbSBsYXllciBNYXJrZXIgdG8gcmUtc3R5bGUgdXNpbmcgdGhlIENsdXN0ZXJzIGljb25DcmVhdGVGdW5jdGlvbi5cblx0XHQgKiBAcmV0dXJucyB7TC5JY29ufSBUaGUgbmV3bHkgY3JlYXRlZCBpY29uLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X292ZXJyaWRlTWFya2VySWNvbjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR2YXIgaWNvbiA9IGxheWVyLm9wdGlvbnMuaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24oe1xuXHRcdFx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBbbGF5ZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGljb247XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBDb25zdGFudCBib3VuZHMgdXNlZCBpbiBjYXNlIG9wdGlvbiBcInJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzXCIgaXMgc2V0IHRvIGZhbHNlLlxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHRfbWFwQm91bmRzSW5maW5pdGU6IG5ldyBMLkxhdExuZ0JvdW5kcyhuZXcgTC5MYXRMbmcoLUluZmluaXR5LCAtSW5maW5pdHkpLCBuZXcgTC5MYXRMbmcoSW5maW5pdHksIEluZmluaXR5KSlcblx0fSk7XG5cblx0TC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XG5cdFx0X25vQW5pbWF0aW9uOiB7XG5cdFx0XHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXG5cdFx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly9EbyBub3RoaW5nLi4uXG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvblpvb21JbjogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXG5cdFx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXG5cdFx0XHRcdC8vV2UgZGlkbid0IGFjdHVhbGx5IGFuaW1hdGUsIGJ1dCB3ZSB1c2UgdGhpcyBldmVudCB0byBtZWFuIFwiY2x1c3RlcmluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcIlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xuXHRcdFx0fSxcblx0XHRcdF9hbmltYXRpb25BZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIG5ld0NsdXN0ZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfd2l0aEFuaW1hdGlvbjoge1xuXHRcdFx0Ly9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXG5cdFx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSArPSAnIGxlYWZsZXQtY2x1c3Rlci1hbmltJztcblx0XHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uKys7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXG5cdFx0XHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdFx0ICAgIGk7XG5cblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdFx0Ly9BZGQgYWxsIGNoaWxkcmVuIG9mIGN1cnJlbnQgY2x1c3RlcnMgdG8gbWFwIGFuZCByZW1vdmUgdGhvc2UgY2x1c3RlcnMgZnJvbSBtYXBcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBzdGFydFBvcyA9IGMuX2xhdGxuZyxcblx0XHRcdFx0XHQgICAgbWFya2VycyAgPSBjLl9tYXJrZXJzLFxuXHRcdFx0XHRcdCAgICBtO1xuXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMoc3RhcnRQb3MpKSB7XG5cdFx0XHRcdFx0XHRzdGFydFBvcyA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgKyAxID09PSBuZXdab29tTGV2ZWwpIHsgLy9JbW1lZGlhdGVseSBhZGQgdGhlIG5ldyBjaGlsZCBhbmQgcmVtb3ZlIHVzXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vRmFkZSBvdXQgb2xkIGNsdXN0ZXJcblx0XHRcdFx0XHRcdGMuY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChzdGFydFBvcywgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vUmVtb3ZlIGFsbCBtYXJrZXJzIHRoYXQgYXJlbid0IHZpc2libGUgYW55IG1vcmVcblx0XHRcdFx0XHQvL1RPRE86IERvIHdlIGFjdHVhbGx5IG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgaGlnaGVyIGxldmVscyB0b28/XG5cdFx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXG5cdFx0XHRcdC8vVXBkYXRlIG9wYWNpdGllc1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XG5cdFx0XHRcdC8vVE9ETyBNYXliZT8gVXBkYXRlIG1hcmtlcnMgaW4gX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZVxuXHRcdFx0XHRmZy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG4pIHtcblx0XHRcdFx0XHRpZiAoIShuIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSAmJiBuLl9pY29uKSB7XG5cdFx0XHRcdFx0XHRuLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwsIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMobmV3Wm9vbUxldmVsKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMgYW5kIGNsb3NlIHRoZSB6b29tIGFuaW1hdGlvblxuXHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcblx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcblx0XHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRpb25ab29tT3V0OiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCwgcHJldmlvdXNab29tTGV2ZWwgLSAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHRcdC8vTmVlZCB0byBhZGQgbWFya2VycyBmb3IgdGhvc2UgdGhhdCB3ZXJlbid0IG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCBhcmUgbm93XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIHRoYXQgd2VyZSBvbiB0aGUgbWFwIGJlZm9yZSBidXQgd29uJ3QgYmUgbm93XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwO1xuXG5cdFx0XHRcdGZnLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0aWYgKG5ld0NsdXN0ZXIgIT09IGxheWVyKSB7XG5cdFx0XHRcdFx0aWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPiAyKSB7IC8vV2FzIGFscmVhZHkgYSBjbHVzdGVyXG5cblx0XHRcdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xuXG5cdFx0XHRcdFx0XHRsYXllci5fc2V0UG9zKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmV3Q2x1c3Rlci5nZXRMYXRMbmcoKSkpO1xuXHRcdFx0XHRcdFx0bGF5ZXIuY2x1c3RlckhpZGUoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcblxuXHRcdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vSnVzdCBiZWNhbWUgYSBjbHVzdGVyXG5cdFx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXG5cdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uU3RhcnQoKTtcblx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5nZXRNYXhab29tKCksIHRoaXMuX3pvb20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBQcml2YXRlIG1ldGhvZHMgZm9yIGFuaW1hdGVkIHZlcnNpb25zLlxuXHRcdF9hbmltYXRpb25ab29tT3V0U2luZ2xlOiBmdW5jdGlvbiAoY2x1c3RlciwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcblxuXHRcdFx0Ly9BbmltYXRlIGFsbCBvZiB0aGUgbWFya2VycyBpbiB0aGUgY2x1c3RlcnMgdG8gbW92ZSB0byB0aGVpciBjbHVzdGVyIGNlbnRlciBwb2ludFxuXHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSwgbmV3Wm9vbUxldmVsKTtcblxuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly9VcGRhdGUgdGhlIG9wYWNpdHkgKElmIHdlIGltbWVkaWF0ZWx5IHNldCBpdCB0aGV5IHdvbid0IGFuaW1hdGUpXG5cdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblxuXHRcdFx0Ly9UT0RPOiBNYXliZSB1c2UgdGhlIHRyYW5zaXRpb24gdGltaW5nIHN0dWZmIHRvIG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlXG5cdFx0XHQvL1doZW4gdGhlIGFuaW1hdGlvbnMgYXJlIGRvbmUsIHRpZHkgdXBcblx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdC8vVGhpcyBjbHVzdGVyIHN0b3BwZWQgYmVpbmcgYSBjbHVzdGVyIGJlZm9yZSB0aGUgdGltZW91dCBmaXJlZFxuXHRcdFx0XHRpZiAoY2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBtID0gY2x1c3Rlci5fbWFya2Vyc1swXTtcblx0XHRcdFx0XHQvL0lmIHdlIHdlcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvbiBhdCB0aGUgdGltZSB0aGVuIHRoZSBvcGFjaXR5IGFuZCBwb3NpdGlvbiBvZiBvdXIgY2hpbGQgY291bGQgYmUgd3Jvbmcgbm93LCBzbyBmaXggaXRcblx0XHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblx0XHRcdFx0XHRtLnNldExhdExuZyhtLmdldExhdExuZygpKTtcblx0XHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9hbmltYXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uLS07XG5cdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xuXHRcdH0sXG5cblx0XHQvL0ZvcmNlIGEgYnJvd3NlciBsYXlvdXQgb2Ygc3R1ZmYgaW4gdGhlIG1hcFxuXHRcdC8vIFNob3VsZCBhcHBseSB0aGUgY3VycmVudCBvcGFjaXR5IGFuZCBsb2NhdGlvbiB0byBhbGwgZWxlbWVudHMgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIGFnYWluIGZvciBhbiBhbmltYXRpb25cblx0XHRfZm9yY2VMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vSW4gbXkgdGVzdGluZyB0aGlzIHdvcmtzLCBpbmZhY3Qgb2Zmc2V0V2lkdGggb2YgYW55IGVsZW1lbnQgc2VlbXMgdG8gd29yay5cblx0XHRcdC8vQ291bGQgbG9vcCBhbGwgdGhpcy5fbGF5ZXJzIGFuZCBkbyB0aGlzIGZvciBlYWNoIF9pY29uIGlmIGl0IHN0b3BzIHdvcmtpbmdcblxuXHRcdFx0TC5VdGlsLmZhbHNlRm4oZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCk7XG5cdFx0fVxuXHR9KTtcblxuXHRMLm1hcmtlckNsdXN0ZXJHcm91cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBMLk1hcmtlckNsdXN0ZXJHcm91cChvcHRpb25zKTtcblx0fTtcblxuXHR2YXIgTWFya2VyQ2x1c3RlciA9IEwuTWFya2VyQ2x1c3RlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cdFx0b3B0aW9uczogTC5JY29uLnByb3RvdHlwZS5vcHRpb25zLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XG5cblx0XHRcdEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYSA/IChhLl9jTGF0TG5nIHx8IGEuZ2V0TGF0TG5nKCkpIDogbmV3IEwuTGF0TG5nKDAsIDApLFxuXHQgICAgICAgICAgICB7IGljb246IHRoaXMsIHBhbmU6IGdyb3VwLm9wdGlvbnMuY2x1c3RlclBhbmUgfSk7XG5cblx0XHRcdHRoaXMuX2dyb3VwID0gZ3JvdXA7XG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fbWFya2VycyA9IFtdO1xuXHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xuXHRcdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXG5cdFx0XHRpZiAoYSkge1xuXHRcdFx0XHR0aGlzLl9hZGRDaGlsZChhKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENoaWxkKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxuXHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSwgaWdub3JlRHJhZ2dlZE1hcmtlcikge1xuXHRcdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2ldLmdldEFsbENoaWxkTWFya2VycyhzdG9yYWdlQXJyYXksIGlnbm9yZURyYWdnZWRNYXJrZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRpZiAoaWdub3JlRHJhZ2dlZE1hcmtlciAmJiB0aGlzLl9tYXJrZXJzW2pdLl9fZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcmFnZUFycmF5LnB1c2godGhpcy5fbWFya2Vyc1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdG9yYWdlQXJyYXk7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0aGUgY291bnQgb2YgaG93IG1hbnkgY2hpbGQgbWFya2VycyB3ZSBoYXZlXG5cdFx0Z2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ291bnQ7XG5cdFx0fSxcblxuXHRcdC8vWm9vbSB0byB0aGUgbWluaW11bSBvZiBzaG93aW5nIGFsbCBvZiB0aGUgY2hpbGQgbWFya2Vycywgb3IgdGhlIGV4dGVudHMgb2YgdGhpcyBjbHVzdGVyXG5cdFx0em9vbVRvQm91bmRzOiBmdW5jdGlvbiAoZml0Qm91bmRzT3B0aW9ucykge1xuXHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLnNsaWNlKCksXG5cdFx0XHRcdG1hcCA9IHRoaXMuX2dyb3VwLl9tYXAsXG5cdFx0XHRcdGJvdW5kc1pvb20gPSBtYXAuZ2V0Qm91bmRzWm9vbSh0aGlzLl9ib3VuZHMpLFxuXHRcdFx0XHR6b29tID0gdGhpcy5fem9vbSArIDEsXG5cdFx0XHRcdG1hcFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBkb3duIHRvIHNlZSBhbGwgb2YgdGhlIG1hcmtlcnNcblx0XHRcdHdoaWxlIChjaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgYm91bmRzWm9vbSA+IHpvb20pIHtcblx0XHRcdFx0em9vbSsrO1xuXHRcdFx0XHR2YXIgbmV3Q2x1c3RlcnMgPSBbXTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZENsdXN0ZXJzID0gbmV3Q2x1c3RlcnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3VuZHNab29tID4gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCB6b29tKTtcblx0XHRcdH0gZWxzZSBpZiAoYm91bmRzWm9vbSA8PSBtYXBab29tKSB7IC8vSWYgZml0Qm91bmRzIHdvdWxkbid0IHpvb20gdXMgZG93biwgem9vbSB1cyBkb3duIGluc3RlYWRcblx0XHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5zZXRWaWV3KHRoaXMuX2xhdGxuZywgbWFwWm9vbSArIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5maXRCb3VuZHModGhpcy5fYm91bmRzLCBmaXRCb3VuZHNPcHRpb25zKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX2JvdW5kcyk7XG5cdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdH0sXG5cblx0XHRfdXBkYXRlSWNvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XG5cdFx0XHRcdHRoaXMuc2V0SWNvbih0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9DbHVkZ2UgZm9yIEljb24sIHdlIHByZXRlbmQgdG8gYmUgYW4gaWNvbiBmb3IgcGVyZm9ybWFuY2Vcblx0XHRjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faWNvbk5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdHRoaXMuX2ljb25PYmogPSB0aGlzLl9ncm91cC5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbih0aGlzKTtcblx0XHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5faWNvbk9iai5jcmVhdGVJY29uKCk7XG5cdFx0fSxcblx0XHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZVNoYWRvdygpO1xuXHRcdH0sXG5cblxuXHRcdF9hZGRDaGlsZDogZnVuY3Rpb24gKG5ldzEsIGlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc2V0Q2x1c3RlckNlbnRlcihuZXcxKTtcblxuXHRcdFx0aWYgKG5ldzEgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcblx0XHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMucHVzaChuZXcxKTtcblx0XHRcdFx0XHRuZXcxLl9fcGFyZW50ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGlsZENvdW50ICs9IG5ldzEuX2NoaWxkQ291bnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFya2Vycy5wdXNoKG5ldzEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX19wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5fX3BhcmVudC5fYWRkQ2hpbGQobmV3MSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1ha2VzIHN1cmUgdGhlIGNsdXN0ZXIgY2VudGVyIGlzIHNldC4gSWYgbm90LCB1c2VzIHRoZSBjaGlsZCBjZW50ZXIgaWYgaXQgaXMgYSBjbHVzdGVyLCBvciB0aGUgbWFya2VyIHBvc2l0aW9uLlxuXHRcdCAqIEBwYXJhbSBjaGlsZCBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2x1c3RlciBjZW50ZXIgaWYgbm90IGRlZmluZWQgeWV0LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3NldENsdXN0ZXJDZW50ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0aWYgKCF0aGlzLl9jTGF0TG5nKSB7XG5cdFx0XHRcdC8vIHdoZW4gY2x1c3RlcmluZywgdGFrZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgYXMgdGhlIGNsdXN0ZXIgY2VudGVyXG5cdFx0XHRcdHRoaXMuX2NMYXRMbmcgPSBjaGlsZC5fY0xhdExuZyB8fCBjaGlsZC5fbGF0bG5nO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBc3NpZ25zIGltcG9zc2libGUgYm91bmRpbmcgdmFsdWVzIHNvIHRoYXQgdGhlIG5leHQgZXh0ZW5kIGVudGlyZWx5IGRldGVybWluZXMgdGhlIG5ldyBib3VuZHMuXG5cdFx0ICogVGhpcyBtZXRob2QgYXZvaWRzIGhhdmluZyB0byB0cmFzaCB0aGUgcHJldmlvdXMgTC5MYXRMbmdCb3VuZHMgb2JqZWN0IGFuZCB0byBjcmVhdGUgYSBuZXcgb25lLCB3aGljaCBpcyBtdWNoIHNsb3dlciBmb3IgdGhpcyBjbGFzcy5cblx0XHQgKiBBcyBsb25nIGFzIHRoZSBib3VuZHMgYXJlIG5vdCBleHRlbmRlZCwgbW9zdCBvdGhlciBtZXRob2RzIHdvdWxkIHByb2JhYmx5IGZhaWwsIGFzIHRoZXkgd291bGQgd2l0aCBib3VuZHMgaW5pdGlhbGl6ZWQgYnV0IG5vdCBleHRlbmRlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZXNldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuXHRcdFx0aWYgKGJvdW5kcy5fc291dGhXZXN0KSB7XG5cdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxhdCA9IEluZmluaXR5O1xuXHRcdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sbmcgPSBJbmZpbml0eTtcblx0XHRcdH1cblx0XHRcdGlmIChib3VuZHMuX25vcnRoRWFzdCkge1xuXHRcdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sYXQgPSAtSW5maW5pdHk7XG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxuZyA9IC1JbmZpbml0eTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3JlY2FsY3VsYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuX21hcmtlcnMsXG5cdFx0XHQgICAgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHQgICAgbGF0U3VtID0gMCxcblx0XHRcdCAgICBsbmdTdW0gPSAwLFxuXHRcdFx0ICAgIHRvdGFsQ291bnQgPSB0aGlzLl9jaGlsZENvdW50LFxuXHRcdFx0ICAgIGksIGNoaWxkLCBjaGlsZExhdExuZywgY2hpbGRDb3VudDtcblxuXHRcdFx0Ly8gQ2FzZSB3aGVyZSBhbGwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYW5kIHdlIGFyZSBsZWZ0IHdpdGgganVzdCBhbiBlbXB0eSBfdG9wQ2x1c3RlckxldmVsLlxuXHRcdFx0aWYgKHRvdGFsQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBvYmplY3QsIGZvciBwZXJmb3JtYW5jZS5cblx0XHRcdHRoaXMuX3Jlc2V0Qm91bmRzKCk7XG5cblx0XHRcdC8vIENoaWxkIG1hcmtlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjaGlsZExhdExuZyA9IG1hcmtlcnNbaV0uX2xhdGxuZztcblxuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkTGF0TG5nKTtcblxuXHRcdFx0XHRsYXRTdW0gKz0gY2hpbGRMYXRMbmcubGF0O1xuXHRcdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGlsZCBjbHVzdGVycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZENsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkID0gY2hpbGRDbHVzdGVyc1tpXTtcblxuXHRcdFx0XHQvLyBSZS1jb21wdXRlIGNoaWxkIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb24gZmlyc3QgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRpZiAoY2hpbGQuX2JvdW5kc05lZWRVcGRhdGUpIHtcblx0XHRcdFx0XHRjaGlsZC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGQuX2JvdW5kcyk7XG5cblx0XHRcdFx0Y2hpbGRMYXRMbmcgPSBjaGlsZC5fd0xhdExuZztcblx0XHRcdFx0Y2hpbGRDb3VudCA9IGNoaWxkLl9jaGlsZENvdW50O1xuXG5cdFx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQgKiBjaGlsZENvdW50O1xuXHRcdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nICogY2hpbGRDb3VudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdGhpcy5fd0xhdExuZyA9IG5ldyBMLkxhdExuZyhsYXRTdW0gLyB0b3RhbENvdW50LCBsbmdTdW0gLyB0b3RhbENvdW50KTtcblxuXHRcdFx0Ly8gUmVzZXQgZGlydHkgZmxhZy5cblx0XHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0Ly9TZXQgb3VyIG1hcmtlcnMgcG9zaXRpb24gYXMgZ2l2ZW4gYW5kIGFkZCBpdCB0byB0aGUgbWFwXG5cdFx0X2FkZFRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MpIHtcblx0XHRcdGlmIChzdGFydFBvcykge1xuXHRcdFx0XHR0aGlzLl9iYWNrdXBMYXRsbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0XHRcdHRoaXMuc2V0TGF0TG5nKHN0YXJ0UG9zKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2dyb3VwLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluOiBmdW5jdGlvbiAoYm91bmRzLCBjZW50ZXIsIG1heFpvb20pIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIG1heFpvb20gLSAxLFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBtYXJrZXJzID0gYy5fbWFya2Vycyxcblx0XHRcdFx0XHRcdGksIG07XG5cdFx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XG5cblx0XHRcdFx0XHRcdC8vT25seSBkbyBpdCBpZiB0aGUgaWNvbiBpcyBzdGlsbCBvbiB0aGUgbWFwXG5cdFx0XHRcdFx0XHRpZiAobS5faWNvbikge1xuXHRcdFx0XHRcdFx0XHRtLl9zZXRQb3MoY2VudGVyKTtcblx0XHRcdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IGMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHRcdFx0XHRqLCBjbTtcblx0XHRcdFx0XHRmb3IgKGogPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRjbSA9IGNoaWxkQ2x1c3RlcnNbal07XG5cdFx0XHRcdFx0XHRpZiAoY20uX2ljb24pIHtcblx0XHRcdFx0XHRcdFx0Y20uX3NldFBvcyhjZW50ZXIpO1xuXHRcdFx0XHRcdFx0XHRjbS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXA6IGZ1bmN0aW9uIChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtYXBNaW5ab29tLFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW4oYm91bmRzLCBjLl9ncm91cC5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChjLmdldExhdExuZygpKS5yb3VuZCgpLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cblx0XHRcdFx0XHQvL1RPRE86IGRlcHRoVG9BbmltYXRlSW4gYWZmZWN0cyBfaXNTaW5nbGVQYXJlbnQsIGlmIHRoZXJlIGlzIGEgbXVsdGl6b29tIHdlIG1heS9tYXkgbm90IGJlLlxuXHRcdFx0XHRcdC8vQXMgYSBoYWNrIHdlIG9ubHkgZG8gYSBhbmltYXRpb24gZnJlZSB6b29tIG9uIGEgc2luZ2xlIGxldmVsIHpvb20sIGlmIHNvbWVvbmUgZG9lcyBtdWx0aXBsZSBsZXZlbHMgdGhlbiB3ZSBhbHdheXMgYW5pbWF0ZVxuXHRcdFx0XHRcdGlmIChjLl9pc1NpbmdsZVBhcmVudCgpICYmIHByZXZpb3VzWm9vbUxldmVsIC0gMSA9PT0gbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsKTsgLy9JbW1lZGlhdGVseSByZW1vdmUgb3VyIGNoaWxkcmVuIGFzIHdlIGFyZSByZXBsYWNpbmcgdGhlbS4gVE9ETyBwcmV2aW91c0JvdW5kcyBub3QgYm91bmRzXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGMuY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjLl9hZGRUb01hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcywgem9vbUxldmVsLCBib3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCkgLSAxLCB6b29tTGV2ZWwsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0aWYgKHpvb21MZXZlbCA9PT0gYy5fem9vbSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vQWRkIG91ciBjaGlsZCBtYXJrZXJzIGF0IHN0YXJ0UG9zIChzbyB0aGV5IGNhbiBiZSBhbmltYXRlZCBvdXQpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBubSA9IGMuX21hcmtlcnNbaV07XG5cblx0XHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRQb3MpIHtcblx0XHRcdFx0XHRcdFx0bm0uX2JhY2t1cExhdGxuZyA9IG5tLmdldExhdExuZygpO1xuXG5cdFx0XHRcdFx0XHRcdG5tLnNldExhdExuZyhzdGFydFBvcyk7XG5cdFx0XHRcdFx0XHRcdGlmIChubS5jbHVzdGVySGlkZSkge1xuXHRcdFx0XHRcdFx0XHRcdG5tLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdGMuX2FkZFRvTWFwKHN0YXJ0UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zOiBmdW5jdGlvbiAoem9vbUxldmVsKSB7XG5cdFx0XHQvL0ZpeCBwb3NpdGlvbnMgb2YgY2hpbGQgbWFya2Vyc1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIG5tID0gdGhpcy5fbWFya2Vyc1tpXTtcblx0XHRcdFx0aWYgKG5tLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdFx0XHRubS5zZXRMYXRMbmcobm0uX2JhY2t1cExhdGxuZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG5tLl9iYWNrdXBMYXRsbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHpvb21MZXZlbCAtIDEgPT09IHRoaXMuX3pvb20pIHtcblx0XHRcdFx0Ly9SZXBvc2l0aW9uIGNoaWxkIGNsdXN0ZXJzXG5cdFx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1tqXS5fcmVzdG9yZVBvc2l0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGsgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1trXS5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMoem9vbUxldmVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfcmVzdG9yZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5fYmFja3VwTGF0bG5nKSB7XG5cdFx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9iYWNrdXBMYXRsbmc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vZXhjZXB0Qm91bmRzOiBJZiBzZXQsIGRvbid0IHJlbW92ZSBhbnkgbWFya2Vycy9jbHVzdGVycyBpbiBpdFxuXHRcdF9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcDogZnVuY3Rpb24gKHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tLCB6b29tTGV2ZWwsIGV4Y2VwdEJvdW5kcykge1xuXHRcdFx0dmFyIG0sIGk7XG5cdFx0XHR0aGlzLl9yZWN1cnNpdmVseShwcmV2aW91c0JvdW5kcywgbWFwTWluWm9vbSAtIDEsIHpvb21MZXZlbCAtIDEsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Ly9SZW1vdmUgbWFya2VycyBhdCBldmVyeSBsZXZlbFxuXHRcdFx0XHRcdGZvciAoaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdG0gPSBjLl9tYXJrZXJzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCFleGNlcHRCb3VuZHMgfHwgIWV4Y2VwdEJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGMuX2dyb3VwLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdC8vUmVtb3ZlIGNoaWxkIGNsdXN0ZXJzIGF0IGp1c3QgdGhlIGJvdHRvbSBsZXZlbFxuXHRcdFx0XHRcdGZvciAoaSA9IGMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdG0gPSBjLl9jaGlsZENsdXN0ZXJzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCFleGNlcHRCb3VuZHMgfHwgIWV4Y2VwdEJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGMuX2dyb3VwLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvL1J1biB0aGUgZ2l2ZW4gZnVuY3Rpb25zIHJlY3Vyc2l2ZWx5IHRvIHRoaXMgYW5kIGNoaWxkIGNsdXN0ZXJzXG5cdFx0Ly8gYm91bmRzVG9BcHBseVRvOiBhIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudGluZyB0aGUgYm91bmRzIG9mIHdoYXQgY2x1c3RlcnMgdG8gcmVjdXJzZSBpbiB0b1xuXHRcdC8vIHpvb21MZXZlbFRvU3RhcnQ6IHpvb20gbGV2ZWwgdG8gc3RhcnQgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcblx0XHQvLyB6b29tTGV2ZWxUb1N0b3A6IHpvb20gbGV2ZWwgdG8gc3RvcCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxuXHRcdC8vIHJ1bkF0RXZlcnlMZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBvbiBldmVyeSBsZXZlbFxuXHRcdC8vIHJ1bkF0Qm90dG9tTGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgYXQgb25seSB0aGUgYm90dG9tIGxldmVsXG5cdFx0X3JlY3Vyc2l2ZWx5OiBmdW5jdGlvbiAoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCkge1xuXHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxuXHRcdFx0ICAgIHpvb20gPSB0aGlzLl96b29tLFxuXHRcdFx0ICAgIGksIGM7XG5cblx0XHRcdGlmICh6b29tTGV2ZWxUb1N0YXJ0IDw9IHpvb20pIHtcblx0XHRcdFx0aWYgKHJ1bkF0RXZlcnlMZXZlbCkge1xuXHRcdFx0XHRcdHJ1bkF0RXZlcnlMZXZlbCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuQXRCb3R0b21MZXZlbCAmJiB6b29tID09PSB6b29tTGV2ZWxUb1N0b3ApIHtcblx0XHRcdFx0XHRydW5BdEJvdHRvbUxldmVsKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh6b29tIDwgem9vbUxldmVsVG9TdGFydCB8fCB6b29tIDwgem9vbUxldmVsVG9TdG9wKSB7XG5cdFx0XHRcdGZvciAoaSA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRjID0gY2hpbGRDbHVzdGVyc1tpXTtcblx0XHRcdFx0XHRpZiAoYy5fYm91bmRzTmVlZFVwZGF0ZSkge1xuXHRcdFx0XHRcdFx0Yy5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGJvdW5kc1RvQXBwbHlUby5pbnRlcnNlY3RzKGMuX2JvdW5kcykpIHtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5KGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL1JldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgdGhlIHBhcmVudCBvZiBvbmx5IG9uZSBjbHVzdGVyIGFuZCB0aGF0IGNsdXN0ZXIgaXMgdGhlIHNhbWUgYXMgdXNcblx0XHRfaXNTaW5nbGVQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vRG9uJ3QgbmVlZCB0byBjaGVjayB0aGlzLl9tYXJrZXJzIGFzIHRoZSByZXN0IHdvbid0IHdvcmsgaWYgdGhlcmUgYXJlIGFueVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiB0aGlzLl9jaGlsZENsdXN0ZXJzWzBdLl9jaGlsZENvdW50ID09PSB0aGlzLl9jaGlsZENvdW50O1xuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0KiBFeHRlbmRzIEwuTWFya2VyIHRvIGluY2x1ZGUgdHdvIGV4dHJhIG1ldGhvZHM6IGNsdXN0ZXJIaWRlIGFuZCBjbHVzdGVyU2hvdy5cblx0KiBcblx0KiBUaGV5IHdvcmsgYXMgc2V0T3BhY2l0eSgwKSBhbmQgc2V0T3BhY2l0eSgxKSByZXNwZWN0aXZlbHksIGJ1dFxuXHQqIGRvbid0IG92ZXJ3cml0ZSB0aGUgb3B0aW9ucy5vcGFjaXR5XG5cdCogXG5cdCovXG5cblx0TC5NYXJrZXIuaW5jbHVkZSh7XG5cdFx0Y2x1c3RlckhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBiYWNrdXAgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgwKTtcblx0XHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gYmFja3VwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRcblx0XHRjbHVzdGVyU2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXHR9KTtcblxuXHRMLkRpc3RhbmNlR3JpZCA9IGZ1bmN0aW9uIChjZWxsU2l6ZSkge1xuXHRcdHRoaXMuX2NlbGxTaXplID0gY2VsbFNpemU7XG5cdFx0dGhpcy5fc3FDZWxsU2l6ZSA9IGNlbGxTaXplICogY2VsbFNpemU7XG5cdFx0dGhpcy5fZ3JpZCA9IHt9O1xuXHRcdHRoaXMuX29iamVjdFBvaW50ID0geyB9O1xuXHR9O1xuXG5cdEwuRGlzdGFuY2VHcmlkLnByb3RvdHlwZSA9IHtcblxuXHRcdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcblx0XHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXG5cdFx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxuXHRcdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxuXHRcdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxuXHRcdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXG5cdFx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcblxuXHRcdFx0dGhpcy5fb2JqZWN0UG9pbnRbc3RhbXBdID0gcG9pbnQ7XG5cblx0XHRcdGNlbGwucHVzaChvYmopO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XG5cdFx0XHR0aGlzLnJlbW92ZU9iamVjdChvYmopO1xuXHRcdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3Qgd2FzIGZvdW5kXG5cdFx0cmVtb3ZlT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG5cdFx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXG5cdFx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcblx0XHRcdCAgICBpLCBsZW47XG5cblx0XHRcdGRlbGV0ZSB0aGlzLl9vYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV07XG5cblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xuXG5cdFx0XHRcdFx0Y2VsbC5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdFx0XHRpZiAobGVuID09PSAxKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgcm93W3hdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0ZWFjaE9iamVjdDogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgaSwgaiwgaywgbGVuLCByb3csIGNlbGwsIHJlbW92ZWQsXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQ7XG5cblx0XHRcdGZvciAoaSBpbiBncmlkKSB7XG5cdFx0XHRcdHJvdyA9IGdyaWRbaV07XG5cblx0XHRcdFx0Zm9yIChqIGluIHJvdykge1xuXHRcdFx0XHRcdGNlbGwgPSByb3dbal07XG5cblx0XHRcdFx0XHRmb3IgKGsgPSAwLCBsZW4gPSBjZWxsLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVkID0gZm4uY2FsbChjb250ZXh0LCBjZWxsW2tdKTtcblx0XHRcdFx0XHRcdGlmIChyZW1vdmVkKSB7XG5cdFx0XHRcdFx0XHRcdGstLTtcblx0XHRcdFx0XHRcdFx0bGVuLS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldE5lYXJPYmplY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgaSwgaiwgaywgcm93LCBjZWxsLCBsZW4sIG9iaiwgZGlzdCxcblx0XHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxuXHRcdFx0ICAgIGNsb3Nlc3REaXN0U3EgPSB0aGlzLl9zcUNlbGxTaXplLFxuXHRcdFx0ICAgIGNsb3Nlc3QgPSBudWxsO1xuXG5cdFx0XHRmb3IgKGkgPSB5IC0gMTsgaSA8PSB5ICsgMTsgaSsrKSB7XG5cdFx0XHRcdHJvdyA9IHRoaXMuX2dyaWRbaV07XG5cdFx0XHRcdGlmIChyb3cpIHtcblxuXHRcdFx0XHRcdGZvciAoaiA9IHggLSAxOyBqIDw9IHggKyAxOyBqKyspIHtcblx0XHRcdFx0XHRcdGNlbGwgPSByb3dbal07XG5cdFx0XHRcdFx0XHRpZiAoY2VsbCkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRvYmogPSBjZWxsW2tdO1xuXHRcdFx0XHRcdFx0XHRcdGRpc3QgPSB0aGlzLl9zcURpc3Qob2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildLCBwb2ludCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXN0IDw9IGNsb3Nlc3REaXN0U3EgJiYgY2xvc2VzdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gb2JqO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNsb3Nlc3Q7XG5cdFx0fSxcblxuXHRcdF9nZXRDb29yZDogZnVuY3Rpb24gKHgpIHtcblx0XHRcdHZhciBjb29yZCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuX2NlbGxTaXplKTtcblx0XHRcdHJldHVybiBpc0Zpbml0ZShjb29yZCkgPyBjb29yZCA6IHg7XG5cdFx0fSxcblxuXHRcdF9zcURpc3Q6IGZ1bmN0aW9uIChwLCBwMikge1xuXHRcdFx0dmFyIGR4ID0gcDIueCAtIHAueCxcblx0XHRcdCAgICBkeSA9IHAyLnkgLSBwLnk7XG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIENvcHlyaWdodCAoYykgMjAxMiB0aGUgYXV0aG9ycyBsaXN0ZWQgYXQgdGhlIGZvbGxvd2luZyBVUkwsIGFuZC9vclxuXHR0aGUgYXV0aG9ycyBvZiByZWZlcmVuY2VkIGFydGljbGVzIG9yIGluY29ycG9yYXRlZCBleHRlcm5hbCBjb2RlOlxuXHRodHRwOi8vZW4ubGl0ZXJhdGVwcm9ncmFtcy5vcmcvUXVpY2todWxsXyhKYXZhc2NyaXB0KT9hY3Rpb249aGlzdG9yeSZvZmZzZXQ9MjAxMjA0MTAxNzUyNTZcblxuXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcblx0YSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cdFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuXHR3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5cdGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuXHRwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cblx0dGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5cdGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5cdEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuXHRNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5cdElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5cdENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5cdFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5cdFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cdFJldHJpZXZlZCBmcm9tOiBodHRwOi8vZW4ubGl0ZXJhdGVwcm9ncmFtcy5vcmcvUXVpY2todWxsXyhKYXZhc2NyaXB0KT9vbGRpZD0xODQzNFxuXHQqL1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0TC5RdWlja0h1bGwgPSB7XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gY3B0IGEgcG9pbnQgdG8gYmUgbWVhc3VyZWQgZnJvbSB0aGUgYmFzZWxpbmVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJsIHRoZSBiYXNlbGluZSwgYXMgcmVwcmVzZW50ZWQgYnkgYSB0d28tZWxlbWVudFxuXHRcdFx0ICogICBhcnJheSBvZiBsYXRsbmcgb2JqZWN0cy5cblx0XHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGRpc3RhbmNlIG1lYXN1cmVcblx0XHRcdCAqL1xuXHRcdFx0Z2V0RGlzdGFudDogZnVuY3Rpb24gKGNwdCwgYmwpIHtcblx0XHRcdFx0dmFyIHZZID0gYmxbMV0ubGF0IC0gYmxbMF0ubGF0LFxuXHRcdFx0XHRcdHZYID0gYmxbMF0ubG5nIC0gYmxbMV0ubG5nO1xuXHRcdFx0XHRyZXR1cm4gKHZYICogKGNwdC5sYXQgLSBibFswXS5sYXQpICsgdlkgKiAoY3B0LmxuZyAtIGJsWzBdLmxuZykpO1xuXHRcdFx0fSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VMaW5lIGEgdHdvLWVsZW1lbnQgYXJyYXkgb2YgbGF0bG5nIG9iamVjdHNcblx0XHRcdCAqICAgcmVwcmVzZW50aW5nIHRoZSBiYXNlbGluZSB0byBwcm9qZWN0IGZyb21cblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3MgYW4gYXJyYXkgb2YgbGF0bG5nIG9iamVjdHNcblx0XHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBtYXhpbXVtIHBvaW50IGFuZCBhbGwgbmV3IHBvaW50cyB0byBzdGF5XG5cdFx0XHQgKiAgIGluIGNvbnNpZGVyYXRpb24gZm9yIHRoZSBodWxsLlxuXHRcdFx0ICovXG5cdFx0XHRmaW5kTW9zdERpc3RhbnRQb2ludEZyb21CYXNlTGluZTogZnVuY3Rpb24gKGJhc2VMaW5lLCBsYXRMbmdzKSB7XG5cdFx0XHRcdHZhciBtYXhEID0gMCxcblx0XHRcdFx0XHRtYXhQdCA9IG51bGwsXG5cdFx0XHRcdFx0bmV3UG9pbnRzID0gW10sXG5cdFx0XHRcdFx0aSwgcHQsIGQ7XG5cblx0XHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcblx0XHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XG5cblx0XHRcdFx0XHRpZiAoZCA+IDApIHtcblx0XHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGQgPiBtYXhEKSB7XG5cdFx0XHRcdFx0XHRtYXhEID0gZDtcblx0XHRcdFx0XHRcdG1heFB0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKlxuXHRcdFx0ICogR2l2ZW4gYSBiYXNlbGluZSwgY29tcHV0ZSB0aGUgY29udmV4IGh1bGwgb2YgbGF0TG5ncyBhcyBhbiBhcnJheVxuXHRcdFx0ICogb2YgbGF0TG5ncy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXG5cdFx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGJ1aWxkQ29udmV4SHVsbDogZnVuY3Rpb24gKGJhc2VMaW5lLCBsYXRMbmdzKSB7XG5cdFx0XHRcdHZhciBjb252ZXhIdWxsQmFzZUxpbmVzID0gW10sXG5cdFx0XHRcdFx0dCA9IHRoaXMuZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmUoYmFzZUxpbmUsIGxhdExuZ3MpO1xuXG5cdFx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxuXHRcdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cblx0XHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxuXHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XG5cdFx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxuXHRcdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogR2l2ZW4gYW4gYXJyYXkgb2YgbGF0bG5ncywgY29tcHV0ZSBhIGNvbnZleCBodWxsIGFzIGFuIGFycmF5XG5cdFx0XHQgKiBvZiBsYXRsbmdzXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xuXHRcdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdFx0ICovXG5cdFx0XHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAobGF0TG5ncykge1xuXHRcdFx0XHQvLyBmaW5kIGZpcnN0IGJhc2VsaW5lXG5cdFx0XHRcdHZhciBtYXhMYXQgPSBmYWxzZSwgbWluTGF0ID0gZmFsc2UsXG5cdFx0XHRcdFx0bWF4TG5nID0gZmFsc2UsIG1pbkxuZyA9IGZhbHNlLFxuXHRcdFx0XHRcdG1heExhdFB0ID0gbnVsbCwgbWluTGF0UHQgPSBudWxsLFxuXHRcdFx0XHRcdG1heExuZ1B0ID0gbnVsbCwgbWluTG5nUHQgPSBudWxsLFxuXHRcdFx0XHRcdG1heFB0ID0gbnVsbCwgbWluUHQgPSBudWxsLFxuXHRcdFx0XHRcdGk7XG5cblx0XHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHZhciBwdCA9IGxhdExuZ3NbaV07XG5cdFx0XHRcdFx0aWYgKG1heExhdCA9PT0gZmFsc2UgfHwgcHQubGF0ID4gbWF4TGF0KSB7XG5cdFx0XHRcdFx0XHRtYXhMYXRQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWF4TGF0ID0gcHQubGF0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWluTGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPCBtaW5MYXQpIHtcblx0XHRcdFx0XHRcdG1pbkxhdFB0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtaW5MYXQgPSBwdC5sYXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXhMbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA+IG1heExuZykge1xuXHRcdFx0XHRcdFx0bWF4TG5nUHQgPSBwdDtcblx0XHRcdFx0XHRcdG1heExuZyA9IHB0LmxuZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pbkxuZyA9PT0gZmFsc2UgfHwgcHQubG5nIDwgbWluTG5nKSB7XG5cdFx0XHRcdFx0XHRtaW5MbmdQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWluTG5nID0gcHQubG5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1pbkxhdCAhPT0gbWF4TGF0KSB7XG5cdFx0XHRcdFx0bWluUHQgPSBtaW5MYXRQdDtcblx0XHRcdFx0XHRtYXhQdCA9IG1heExhdFB0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1pblB0ID0gbWluTG5nUHQ7XG5cdFx0XHRcdFx0bWF4UHQgPSBtYXhMbmdQdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xuXHRcdFx0XHRyZXR1cm4gY2g7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpKTtcblxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cdFx0Z2V0Q29udmV4SHVsbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXG5cdFx0XHRcdHBvaW50cyA9IFtdLFxuXHRcdFx0XHRwLCBpO1xuXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0cCA9IGNoaWxkTWFya2Vyc1tpXS5nZXRMYXRMbmcoKTtcblx0XHRcdFx0cG9pbnRzLnB1c2gocCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL1RoaXMgY29kZSBpcyAxMDAlIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXdqL092ZXJsYXBwaW5nTWFya2VyU3BpZGVyZmllci1MZWFmbGV0XG5cdC8vSHVnZSB0aGFua3MgdG8gamF3aiBmb3IgaW1wbGVtZW50aW5nIGl0IGZpcnN0IHRvIG1ha2UgbXkgam9iIGVhc3kgOi0pXG5cblx0TC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xuXG5cdFx0XzJQSTogTWF0aC5QSSAqIDIsXG5cdFx0X2NpcmNsZUZvb3RTZXBhcmF0aW9uOiAyNSwgLy9yZWxhdGVkIHRvIGNpcmN1bWZlcmVuY2Ugb2YgY2lyY2xlXG5cdFx0X2NpcmNsZVN0YXJ0QW5nbGU6IDAsXG5cblx0XHRfc3BpcmFsRm9vdFNlcGFyYXRpb246ICAyOCwgLy9yZWxhdGVkIHRvIHNpemUgb2Ygc3BpcmFsIChleHBlcmltZW50ISlcblx0XHRfc3BpcmFsTGVuZ3RoU3RhcnQ6IDExLFxuXHRcdF9zcGlyYWxMZW5ndGhGYWN0b3I6IDUsXG5cblx0XHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcblxuXHRcdHNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPT09IHRoaXMgfHwgdGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0Y2VudGVyID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxuXHRcdFx0XHRwb3NpdGlvbnM7XG5cblx0XHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IHRoaXM7XG5cblx0XHRcdC8vVE9ETyBNYXliZTogY2hpbGRNYXJrZXJzIG9yZGVyIGJ5IGRpc3RhbmNlIHRvIGNlbnRlclxuXG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeVNoYXBlUG9zaXRpb25zKSB7XG5cdFx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlTaGFwZVBvc2l0aW9ucyhjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChjaGlsZE1hcmtlcnMubGVuZ3RoID49IHRoaXMuX2NpcmNsZVNwaXJhbFN3aXRjaG92ZXIpIHtcblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNTcGlyYWwoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbnRlci55ICs9IDEwOyAvLyBPdGhlcndpc2UgY2lyY2xlcyBsb29rIHdyb25nID0+IGhhY2sgZm9yIHN0YW5kYXJkIGJsdWUgaWNvbiwgcmVuZGVycyBkaWZmZXJlbnRseSBmb3Igb3RoZXIgaWNvbnMuXG5cdFx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dlbmVyYXRlUG9pbnRzQ2lyY2xlKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FuaW1hdGlvblNwaWRlcmZ5KGNoaWxkTWFya2VycywgcG9zaXRpb25zKTtcblx0XHR9LFxuXG5cdFx0dW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XG5cdFx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxuXHRcdFx0aWYgKHRoaXMuX2dyb3VwLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uVW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XG5cblx0XHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlUG9pbnRzQ2lyY2xlOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XG5cdFx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9jaXJjbGVGb290U2VwYXJhdGlvbiAqICgyICsgY291bnQpLFxuXHRcdFx0XHRsZWdMZW5ndGggPSBjaXJjdW1mZXJlbmNlIC8gdGhpcy5fMlBJLCAgLy9yYWRpdXMgZnJvbSBjaXJjdW1mZXJlbmNlXG5cdFx0XHRcdGFuZ2xlU3RlcCA9IHRoaXMuXzJQSSAvIGNvdW50LFxuXHRcdFx0XHRyZXMgPSBbXSxcblx0XHRcdFx0aSwgYW5nbGU7XG5cblx0XHRcdGxlZ0xlbmd0aCA9IE1hdGgubWF4KGxlZ0xlbmd0aCwgMzUpOyAvLyBNaW5pbXVtIGRpc3RhbmNlIHRvIGdldCBvdXRzaWRlIHRoZSBjbHVzdGVyIGljb24uXG5cblx0XHRcdHJlcy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHsgLy8gQ2xvY2t3aXNlLCBsaWtlIHNwaXJhbC5cblx0XHRcdFx0YW5nbGUgPSB0aGlzLl9jaXJjbGVTdGFydEFuZ2xlICsgaSAqIGFuZ2xlU3RlcDtcblx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdF9nZW5lcmF0ZVBvaW50c1NwaXJhbDogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xuXHRcdFx0dmFyIHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllcixcblx0XHRcdFx0bGVnTGVuZ3RoID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhTdGFydCxcblx0XHRcdFx0c2VwYXJhdGlvbiA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsRm9vdFNlcGFyYXRpb24sXG5cdFx0XHRcdGxlbmd0aEZhY3RvciA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsTGVuZ3RoRmFjdG9yICogdGhpcy5fMlBJLFxuXHRcdFx0XHRhbmdsZSA9IDAsXG5cdFx0XHRcdHJlcyA9IFtdLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHRyZXMubGVuZ3RoID0gY291bnQ7XG5cblx0XHRcdC8vIEhpZ2hlciBpbmRleCwgY2xvc2VyIHBvc2l0aW9uIHRvIGNsdXN0ZXIgY2VudGVyLlxuXHRcdFx0Zm9yIChpID0gY291bnQ7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdC8vIFNraXAgdGhlIGZpcnN0IHBvc2l0aW9uLCBzbyB0aGF0IHdlIGFyZSBhbHJlYWR5IGZhcnRoZXIgZnJvbSBjZW50ZXIgYW5kIHdlIGF2b2lkXG5cdFx0XHRcdC8vIGJlaW5nIHVuZGVyIHRoZSBkZWZhdWx0IGNsdXN0ZXIgaWNvbiAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIENpcmNsZSBNYXJrZXJzKS5cblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xuXHRcdFx0XHRsZWdMZW5ndGggKz0gbGVuZ3RoRmFjdG9yIC8gYW5nbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRfbm9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0bSwgaTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMSk7XG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblxuXHRcdFx0XHRpZiAobS5fcHJlU3BpZGVyZnlMYXRsbmcpIHtcblx0XHRcdFx0XHRtLnNldExhdExuZyhtLl9wcmVTcGlkZXJmeUxhdGxuZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3ByZVNwaWRlcmZ5TGF0bG5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG0uX3NwaWRlckxlZykge1xuXHRcdFx0XHRcdG1hcC5yZW1vdmVMYXllcihtLl9zcGlkZXJMZWcpO1xuXHRcdFx0XHRcdGRlbGV0ZSBtLl9zcGlkZXJMZWc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xuXHRcdFx0XHRjbHVzdGVyOiB0aGlzLFxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdH0pO1xuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdGdyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcblx0TC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQgPSBMLk1hcmtlckNsdXN0ZXIuZXh0ZW5kKHtcblx0XHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xuXHRcdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXG5cdFx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0bGVnT3B0aW9ucyA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLFxuXHRcdFx0XHRpLCBtLCBsZWcsIG5ld1BvcztcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHQvLyBUcmF2ZXJzZSBpbiBhc2NlbmRpbmcgb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaW5uZXIgY2lyY2xlTWFya2VycyBhcmUgb24gdG9wIG9mIGZ1cnRoZXIgbGVncy4gTm9ybWFsIG1hcmtlcnMgYXJlIHJlLW9yZGVyZWQgYnkgbmV3UG9zaXRpb24uXG5cdFx0XHQvLyBUaGUgcmV2ZXJzZSBvcmRlciB0cmljayBubyBsb25nZXIgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb24gbW9kZXJuIGJyb3dzZXJzLlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTWFya2Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cblx0XHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXMuX2xhdGxuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XG5cdFx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xuXHRcdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XG5cblx0XHRcdFx0Ly8gTm93IGFkZCB0aGUgbWFya2VyLlxuXHRcdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcblx0XHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vTWFrZSB0aGVzZSBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZnLmFkZExheWVyKG0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cdFx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJywge1xuXHRcdFx0XHRjbHVzdGVyOiB0aGlzLFxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcblx0TC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xuXG5cdFx0X2FuaW1hdGlvblNwaWRlcmZ5OiBmdW5jdGlvbiAoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpIHtcblx0XHRcdHZhciBtZSA9IHRoaXMsXG5cdFx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXG5cdFx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0dGhpc0xheWVyTGF0TG5nID0gdGhpcy5fbGF0bG5nLFxuXHRcdFx0XHR0aGlzTGF5ZXJQb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXNMYXllckxhdExuZyksXG5cdFx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXG5cdFx0XHRcdGxlZ09wdGlvbnMgPSBMLmV4dGVuZCh7fSwgdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMpLCAvLyBDb3B5IHRoZSBvcHRpb25zIHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGVtIGZvciBhbmltYXRpb24uXG5cdFx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IGxlZ09wdGlvbnMub3BhY2l0eSxcblx0XHRcdFx0aSwgbSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5ld1BvcztcblxuXHRcdFx0aWYgKGZpbmFsTGVnT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwLnByb3RvdHlwZS5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBpbml0aWFsIG9wYWNpdHkgb2YgdGhlIHNwaWRlciBsZWcgaXMgbm90IDAgdGhlbiBpdCBhcHBlYXJzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cblx0XHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gMDtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIGNsYXNzIGZvciBDU1MgdHJhbnNpdGlvbnMuXG5cdFx0XHRcdGxlZ09wdGlvbnMuY2xhc3NOYW1lID0gKGxlZ09wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC1jbHVzdGVyLXNwaWRlci1sZWcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmUgYSBkZWZpbmVkIG9wYWNpdHkuXG5cdFx0XHRcdGxlZ09wdGlvbnMub3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHQvLyBBZGQgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MgdG8gbWFwLCBoaWRkZW4gYXQgb3VyIGNlbnRlciBwb2ludC5cblx0XHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cblx0XHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXG5cdFx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzTGF5ZXJMYXRMbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xuXHRcdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcblx0XHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xuXG5cdFx0XHRcdC8vIEV4cGxhbmF0aW9uczogaHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDEzL2FuaW1hdGVkLWxpbmUtZHJhd2luZy1zdmcvXG5cdFx0XHRcdC8vIEluIG91ciBjYXNlIHRoZSB0cmFuc2l0aW9uIHByb3BlcnR5IGlzIGRlY2xhcmVkIGluIHRoZSBDU1MgZmlsZS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xOyAvLyBOZWVkIGEgc21hbGwgZXh0cmEgbGVuZ3RoIHRvIGF2b2lkIHJlbWFpbmluZyBkb3QgaW4gRmlyZWZveC5cblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IGxlZ0xlbmd0aDsgLy8gSnVzdCAxIGxlbmd0aCBpcyBlbm91Z2gsIGl0IHdpbGwgYmUgZHVwbGljYXRlZC5cblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG1hcmtlciwgYWRkIGl0IG5vdyBhbmQgd2UnbGwgYW5pbWF0ZSBpdCBvdXRcblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vIE1ha2Ugbm9ybWFsIG1hcmtlcnMgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcblx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFZlY3RvcnMganVzdCBnZXQgaW1tZWRpYXRlbHkgYWRkZWRcblx0XHRcdFx0ZmcuYWRkTGF5ZXIobSk7XG5cblx0XHRcdFx0aWYgKG0uX3NldFBvcykge1xuXHRcdFx0XHRcdG0uX3NldFBvcyh0aGlzTGF5ZXJQb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdyb3VwLl9mb3JjZUxheW91dCgpO1xuXHRcdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdC8vIFJldmVhbCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncy5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly9Nb3ZlIG1hcmtlciB0byBuZXcgcG9zaXRpb25cblx0XHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XG5cdFx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFuaW1hdGUgbGVnIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcblx0XHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDA7XG5cdFx0XHRcdFx0Ly9sZWdQYXRoLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XG5cdFx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiBmaW5hbExlZ09wYWNpdHl9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdFx0Y2x1c3RlcjogbWUsXG5cdFx0XHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMjAwKTtcblx0XHR9LFxuXG5cdFx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHR0aGlzTGF5ZXJQb3MgPSB6b29tRGV0YWlscyA/IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgem9vbURldGFpbHMuem9vbSwgem9vbURldGFpbHMuY2VudGVyKSA6IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcblx0XHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMobnVsbCwgdHJ1ZSksXG5cdFx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXG5cdFx0XHRcdG0sIGksIGxlZywgbGVnUGF0aCwgbGVnTGVuZ3RoLCBub25BbmltYXRhYmxlO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cdFx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdC8vTWFya2VyIHdhcyBhZGRlZCB0byB1cyBhZnRlciB3ZSB3ZXJlIHNwaWRlcmZpZWRcblx0XHRcdFx0aWYgKCFtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9DbG9zZSBhbnkgcG9wdXAgb24gdGhlIG1hcmtlciBmaXJzdCwgb3RoZXJ3aXNlIHNldHRpbmcgdGhlIGxvY2F0aW9uIG9mIHRoZSBtYXJrZXIgd2lsbCBtYWtlIHRoZSBtYXAgc2Nyb2xsXG5cdFx0XHRcdG0uY2xvc2VQb3B1cCgpO1xuXG5cdFx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xuXHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XG5cblx0XHRcdFx0Ly9IYWNrIG92ZXJyaWRlIHRoZSBsb2NhdGlvbiB0byBiZSBvdXIgY2VudGVyXG5cdFx0XHRcdG5vbkFuaW1hdGFibGUgPSB0cnVlO1xuXHRcdFx0XHRpZiAobS5fc2V0UG9zKSB7XG5cdFx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XG5cdFx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJIaWRlKSB7XG5cdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdG5vbkFuaW1hdGFibGUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9uQW5pbWF0YWJsZSkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQW5pbWF0ZSB0aGUgc3BpZGVyIGxlZyBiYWNrIGluIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcblx0XHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xuXHRcdFx0XHRcdGxlZ0xlbmd0aCA9IGxlZ1BhdGguZ2V0VG90YWxMZW5ndGgoKSArIDAuMTtcblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XG5cdFx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiAwfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vSWYgd2UgaGF2ZSBvbmx5IDw9IG9uZSBjaGlsZCBsZWZ0IHRoZW4gdGhhdCBtYXJrZXIgd2lsbCBiZSBzaG93biBvbiB0aGUgbWFwIHNvIGRvbid0IHJlbW92ZSBpdCFcblx0XHRcdFx0dmFyIHN0aWxsVGhlcmVDaGlsZENvdW50ID0gMDtcblx0XHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblx0XHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XG5cdFx0XHRcdFx0XHRzdGlsbFRoZXJlQ2hpbGRDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdGlmICghbS5fc3BpZGVyTGVnKSB7IC8vSGFzIGFscmVhZHkgYmVlbiB1bnNwaWRlcmZpZWRcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcblx0XHRcdFx0fVxuXHRcdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdGdyb3VwLmZpcmUoJ3Vuc3BpZGVyZmllZCcsIHtcblx0XHRcdFx0XHRjbHVzdGVyOiBtZSxcblx0XHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAyMDApO1xuXHRcdH1cblx0fSk7XG5cblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXG5cdFx0X3NwaWRlcmZpZWQ6IG51bGwsXG5cblx0XHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9zcGlkZXJmaWVyT25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XG5cblx0XHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XG5cdFx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xuXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdFx0XHRcdC8vTmVlZHMgdG8gaGFwcGVuIGluIHRoZSBwYWdlbG9hZCwgbm90IGFmdGVyLCBvciBhbmltYXRpb25zIGRvbid0IHdvcmsgaW4gd2Via2l0XG5cdFx0XHRcdC8vICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTUyMDAvc3ZnLWFuaW1hdGUtd2l0aC1keW5hbWljYWxseS1hZGRlZC1lbGVtZW50c1xuXHRcdFx0XHQvL0Rpc2FibGUgb24gdG91Y2ggYnJvd3NlcnMgYXMgdGhlIGFuaW1hdGlvbiBtZXNzZXMgdXAgb24gYSB0b3VjaCB6b29tIGFuZCBpc24ndCB2ZXJ5IG5vdGljYWJsZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc3BpZGVyZmllck9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcblx0XHRcdHRoaXMuX21hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMuX3Vuc3BpZGVyZnlab29tU3RhcnQsIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbUFuaW0sIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSwgdGhpcyk7XG5cblx0XHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxuXHRcdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcblx0XHR9LFxuXG5cdFx0Ly9PbiB6b29tIHN0YXJ0IHdlIGFkZCBhIHpvb21hbmltIGhhbmRsZXIgc28gdGhhdCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBiZSBsYXN0IChhZnRlciBtYXJrZXJzIGFyZSBhbmltYXRlZClcblx0XHQvL1RoaXMgbWVhbnMgd2UgY2FuIGRlZmluZSB0aGUgYW5pbWF0aW9uIHRoZXkgZG8gcmF0aGVyIHRoYW4gTWFya2VycyBkb2luZyBhbiBhbmltYXRpb24gdG8gdGhlaXIgYWN0dWFsIGxvY2F0aW9uXG5cdFx0X3Vuc3BpZGVyZnlab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21hcC5vbignem9vbWFuaW0nLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbUFuaW0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxuXHRcdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblx0XHR9LFxuXG5cdFx0X3Vuc3BpZGVyZnlXcmFwcGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLy8gPHN1bW1hcnk+X3Vuc3BpZGVyZnkgYnV0IHBhc3NlcyBubyBhcmd1bWVudHM8L3N1bW1hcnk+XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0fSxcblxuXHRcdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZWQuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0lmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYmVpbmcgc3BpZGVyZmllZCB0aGVuIHdlIHVuc3BpZGVyZnkgaXQgc28gaXQgaXNuJ3Qgb24gdGhlIG1hcCBhbnltb3JlIGV0Y1xuXHRcdF91bnNwaWRlcmZ5TGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0aWYgKGxheWVyLl9zcGlkZXJMZWcpIHtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblxuXHRcdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XG5cdFx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXIuX3NwaWRlckxlZyk7XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5fc3BpZGVyTGVnO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEFkZHMgMSBwdWJsaWMgbWV0aG9kIHRvIE1DRyBhbmQgMSB0byBMLk1hcmtlciB0byBmYWNpbGl0YXRlIGNoYW5naW5nXG5cdCAqIG1hcmtlcnMnIGljb24gb3B0aW9ucyBhbmQgcmVmcmVzaGluZyB0aGVpciBpY29uIGFuZCB0aGVpciBwYXJlbnQgY2x1c3RlcnNcblx0ICogYWNjb3JkaW5nbHkgKGNhc2Ugd2hlcmUgdGhlaXIgaWNvbkNyZWF0ZUZ1bmN0aW9uIHVzZXMgZGF0YSBvZiBjaGlsZE1hcmtlcnNcblx0ICogdG8gbWFrZSB1cCB0aGUgY2x1c3RlciBpY29uKS5cblx0ICovXG5cblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBpY29uIG9mIGFsbCBjbHVzdGVycyB3aGljaCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gbWFya2VyKHMpLlxuXHRcdCAqIEluIHNpbmdsZU1hcmtlck1vZGUsIGFsc28gdXBkYXRlcyB0aGUgZ2l2ZW4gbWFya2VyKHMpIGljb24uXG5cdFx0ICogQHBhcmFtIGxheWVycyBMLk1hcmtlckNsdXN0ZXJHcm91cHxMLkxheWVyR3JvdXB8QXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcil8XG5cdFx0ICogTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIChvcHRpb25hbCkgbGlzdCBvZiBtYXJrZXJzIChvciBzaW5nbGUgbWFya2VyKSB3aG9zZSBwYXJlbnRcblx0XHQgKiBjbHVzdGVycyBuZWVkIHRvIGJlIHVwZGF0ZWQuIElmIG5vdCBwcm92aWRlZCwgcmV0cmlldmVzIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMuXG5cdFx0ICogQHJldHVybnMge0wuTWFya2VyQ2x1c3Rlckdyb3VwfVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hDbHVzdGVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0aWYgKCFsYXllcnMpIHtcblx0XHRcdFx0bGF5ZXJzID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXJHcm91cCkge1xuXHRcdFx0XHRsYXllcnMgPSBsYXllcnMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdGxheWVycyA9IGxheWVycy5fbGF5ZXJzO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcblx0XHRcdFx0bGF5ZXJzID0gbGF5ZXJzLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0XHRsYXllcnMgPSBbbGF5ZXJzXTtcblx0XHRcdH0gLy8gZWxzZTogbXVzdCBiZSBhbiBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKVxuXHRcdFx0dGhpcy5fZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGUobGF5ZXJzKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdC8vIEluIGNhc2Ugb2Ygc2luZ2xlTWFya2VyTW9kZSwgYWxzbyByZS1kcmF3IHRoZSBtYXJrZXJzLlxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyhsYXllcnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2ltcGx5IGZsYWdzIGFsbCBwYXJlbnQgY2x1c3RlcnMgb2YgdGhlIGdpdmVuIG1hcmtlcnMgYXMgaGF2aW5nIGEgXCJkaXJ0eVwiIGljb24uXG5cdFx0ICogQHBhcmFtIGxheWVycyBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKSBsaXN0IG9mIG1hcmtlcnMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGU6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRcdHZhciBpZCwgcGFyZW50O1xuXG5cdFx0XHQvLyBBc3N1bWVzIGxheWVycyBpcyBhbiBBcnJheSBvciBhbiBPYmplY3Qgd2hvc2UgcHJvdG90eXBlIGlzIG5vbi1lbnVtZXJhYmxlLlxuXHRcdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcblx0XHRcdFx0Ly8gRmxhZyBwYXJlbnQgY2x1c3RlcnMnIGljb24gYXMgXCJkaXJ0eVwiLCBhbGwgdGhlIHdheSB1cC5cblx0XHRcdFx0Ly8gRHVtYiBwcm9jZXNzIHRoYXQgZmxhZ3MgbXVsdGlwbGUgdGltZXMgdXBwZXIgcGFyZW50cywgYnV0IHN0aWxsXG5cdFx0XHRcdC8vIG11Y2ggbW9yZSBlZmZpY2llbnQgdGhhbiB0cnlpbmcgdG8gYmUgc21hcnQgYW5kIG1ha2Ugc2hvcnQgbGlzdHMsXG5cdFx0XHRcdC8vIGF0IGxlYXN0IGluIHRoZSBjYXNlIG9mIGEgaGllcmFyY2h5IGZvbGxvd2luZyBhIHBvd2VyIGxhdzpcblx0XHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vZmxhZy1ub2Rlcy1pbi1wb3dlci1oaWVyYXJjaHkvMlxuXHRcdFx0XHRwYXJlbnQgPSBsYXllcnNbaWRdLl9fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdFx0cGFyZW50Ll9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZS1kcmF3cyB0aGUgaWNvbiBvZiB0aGUgc3VwcGxpZWQgbWFya2Vycy5cblx0XHQgKiBUbyBiZSB1c2VkIGluIHNpbmdsZU1hcmtlck1vZGUgb25seS5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRcdHZhciBpZCwgbGF5ZXI7XG5cblx0XHRcdGZvciAoaWQgaW4gbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gbGF5ZXJzW2lkXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgZG8gbm90IG92ZXJyaWRlIG1hcmtlcnMgdGhhdCBkbyBub3QgYmVsb25nIHRvIFRISVMgZ3JvdXAuXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdC8vIE5lZWQgdG8gcmUtY3JlYXRlIHRoZSBpY29uIGZpcnN0LCB0aGVuIHJlLWRyYXcgdGhlIG1hcmtlci5cblx0XHRcdFx0XHRsYXllci5zZXRJY29uKHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRMLk1hcmtlci5pbmNsdWRlKHtcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBnaXZlbiBvcHRpb25zIGluIHRoZSBtYXJrZXIncyBpY29uIGFuZCByZWZyZXNoZXMgdGhlIG1hcmtlci5cblx0XHQgKiBAcGFyYW0gb3B0aW9ucyBtYXAgb2JqZWN0IG9mIGljb24gb3B0aW9ucy5cblx0XHQgKiBAcGFyYW0gZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgYm9vbGVhbiAob3B0aW9uYWwpIHRydWUgdG8gdHJpZ2dlclxuXHRcdCAqIE1DRy5yZWZyZXNoQ2x1c3RlcnNPZigpIHJpZ2h0IGF3YXkgd2l0aCB0aGlzIHNpbmdsZSBtYXJrZXIuXG5cdFx0ICogQHJldHVybnMge0wuTWFya2VyfVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hJY29uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMsIGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzKSB7XG5cdFx0XHR2YXIgaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uO1xuXG5cdFx0XHRMLnNldE9wdGlvbnMoaWNvbiwgb3B0aW9ucyk7XG5cblx0XHRcdHRoaXMuc2V0SWNvbihpY29uKTtcblxuXHRcdFx0Ly8gU2hvcnRjdXQgdG8gcmVmcmVzaCB0aGUgYXNzb2NpYXRlZCBNQ0cgY2x1c3RlcnMgcmlnaHQgYXdheS5cblx0XHRcdC8vIFRvIGJlIHVzZWQgd2hlbiByZWZyZXNoaW5nIGEgc2luZ2xlIG1hcmtlci5cblx0XHRcdC8vIE90aGVyd2lzZSwgYmV0dGVyIHVzZSBNQ0cucmVmcmVzaENsdXN0ZXJzKCkgb25jZSBhdCB0aGUgZW5kIHdpdGhcblx0XHRcdC8vIHRoZSBsaXN0IG9mIG1vZGlmaWVkIG1hcmtlcnMuXG5cdFx0XHRpZiAoZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgJiYgdGhpcy5fX3BhcmVudCkge1xuXHRcdFx0XHR0aGlzLl9fcGFyZW50Ll9ncm91cC5yZWZyZXNoQ2x1c3RlcnModGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cblx0ZXhwb3J0cy5NYXJrZXJDbHVzdGVyR3JvdXAgPSBNYXJrZXJDbHVzdGVyR3JvdXA7XG5cdGV4cG9ydHMuTWFya2VyQ2x1c3RlciA9IE1hcmtlckNsdXN0ZXI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJMZWFmbGV0IiwibWFya2VyY2x1c3RlciIsIk1hcmtlckNsdXN0ZXJHcm91cCIsIkwiLCJGZWF0dXJlR3JvdXAiLCJleHRlbmQiLCJvcHRpb25zIiwibWF4Q2x1c3RlclJhZGl1cyIsImljb25DcmVhdGVGdW5jdGlvbiIsImNsdXN0ZXJQYW5lIiwiTWFya2VyIiwicHJvdG90eXBlIiwicGFuZSIsInNwaWRlcmZ5T25FdmVyeVpvb20iLCJzcGlkZXJmeU9uTWF4Wm9vbSIsInNob3dDb3ZlcmFnZU9uSG92ZXIiLCJ6b29tVG9Cb3VuZHNPbkNsaWNrIiwic2luZ2xlTWFya2VyTW9kZSIsImRpc2FibGVDbHVzdGVyaW5nQXRab29tIiwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMiLCJhbmltYXRlIiwiYW5pbWF0ZUFkZGluZ01hcmtlcnMiLCJzcGlkZXJmeVNoYXBlUG9zaXRpb25zIiwic3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIiLCJzcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMiLCJ3ZWlnaHQiLCJjb2xvciIsIm9wYWNpdHkiLCJjaHVua2VkTG9hZGluZyIsImNodW5rSW50ZXJ2YWwiLCJjaHVua0RlbGF5IiwiY2h1bmtQcm9ncmVzcyIsInBvbHlnb25PcHRpb25zIiwiaW5pdGlhbGl6ZSIsIlV0aWwiLCJzZXRPcHRpb25zIiwiX2RlZmF1bHRJY29uQ3JlYXRlRnVuY3Rpb24iLCJfZmVhdHVyZUdyb3VwIiwiZmVhdHVyZUdyb3VwIiwiYWRkRXZlbnRQYXJlbnQiLCJfbm9uUG9pbnRHcm91cCIsIl9pblpvb21BbmltYXRpb24iLCJfbmVlZHNDbHVzdGVyaW5nIiwiX25lZWRzUmVtb3ZpbmciLCJfY3VycmVudFNob3duQm91bmRzIiwiX3F1ZXVlIiwiX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycyIsIl9jaGlsZE1hcmtlckRyYWdTdGFydCIsIl9jaGlsZE1hcmtlck1vdmVkIiwiX2NoaWxkTWFya2VyRHJhZ0VuZCIsIkRvbVV0aWwiLCJUUkFOU0lUSU9OIiwiX3dpdGhBbmltYXRpb24iLCJfbm9BbmltYXRpb24iLCJfbWFya2VyQ2x1c3RlciIsIk1hcmtlckNsdXN0ZXIiLCJNYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQiLCJhZGRMYXllciIsImxheWVyIiwiTGF5ZXJHcm91cCIsImFkZExheWVycyIsImdldExhdExuZyIsImZpcmUiLCJfbWFwIiwicHVzaCIsImhhc0xheWVyIiwiX3Vuc3BpZGVyZnkiLCJfYWRkTGF5ZXIiLCJfbWF4Wm9vbSIsIl90b3BDbHVzdGVyTGV2ZWwiLCJfcmVjYWxjdWxhdGVCb3VuZHMiLCJfcmVmcmVzaENsdXN0ZXJzSWNvbnMiLCJ2aXNpYmxlTGF5ZXIiLCJjdXJyZW50Wm9vbSIsIl96b29tIiwiX19wYXJlbnQiLCJjb250YWlucyIsIl9hbmltYXRpb25BZGRMYXllciIsIl9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkIiwicmVtb3ZlTGF5ZXIiLCJyZW1vdmVMYXllcnMiLCJfYXJyYXlTcGxpY2UiLCJsYXRsbmciLCJfbGF0bG5nIiwiX3Vuc3BpZGVyZnlMYXllciIsIl9yZW1vdmVMYXllciIsIm9mZiIsImNsdXN0ZXJTaG93IiwibGF5ZXJzQXJyYXkiLCJza2lwTGF5ZXJBZGRFdmVudCIsImlzQXJyYXkiLCJmZyIsIm5wZyIsImNodW5rZWQiLCJsIiwibGVuZ3RoIiwib2Zmc2V0Iiwib3JpZ2luYWxBcnJheSIsIm0iLCJzdGFydGVkIiwiRGF0ZSIsImdldFRpbWUiLCJwcm9jZXNzIiwiYmluZCIsInN0YXJ0IiwiZWxhcHNlZCIsInNsaWNlIiwiX2V4dHJhY3ROb25Hcm91cExheWVycyIsImdldENoaWxkQ291bnQiLCJtYXJrZXJzIiwiZ2V0QWxsQ2hpbGRNYXJrZXJzIiwib3RoZXJNYXJrZXIiLCJfcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwIiwic2V0VGltZW91dCIsIm5lZWRzQ2x1c3RlcmluZyIsImkiLCJsYXllcnNBcnJheTIiLCJsMiIsImNsZWFyTGF5ZXJzIiwiX2dyaWRDbHVzdGVycyIsIl9ncmlkVW5jbHVzdGVyZWQiLCJfbm9hbmltYXRpb25VbnNwaWRlcmZ5IiwiZWFjaExheWVyIiwibWFya2VyIiwiX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzIiwiZ2V0Qm91bmRzIiwiYm91bmRzIiwiTGF0TG5nQm91bmRzIiwiX2JvdW5kcyIsIm1ldGhvZCIsImNvbnRleHQiLCJuZWVkc1JlbW92aW5nIiwidGhpc05lZWRzUmVtb3ZpbmciLCJqIiwiY2FsbCIsImdldExheWVycyIsImxheWVycyIsImdldExheWVyIiwiaWQiLCJyZXN1bHQiLCJwYXJzZUludCIsInN0YW1wIiwiYW5BcnJheSIsIl9ncm91cCIsInpvb21Ub1Nob3dMYXllciIsImNhbGxiYWNrIiwibWFwIiwic2hvd01hcmtlciIsIl9pY29uIiwib25jZSIsInNwaWRlcmZ5IiwiTWF0aCIsInJvdW5kIiwib24iLCJwYW5UbyIsInpvb21Ub0JvdW5kcyIsIm9uQWRkIiwiaXNGaW5pdGUiLCJnZXRNYXhab29tIiwiYWRkVG8iLCJfbWF4TGF0IiwiY3JzIiwicHJvamVjdGlvbiIsIk1BWF9MQVRJVFVERSIsIm5ld2xhdGxuZyIsIl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMiLCJfem9vbUVuZCIsIl9tb3ZlRW5kIiwiX3NwaWRlcmZpZXJPbkFkZCIsIl9iaW5kRXZlbnRzIiwib25SZW1vdmUiLCJfdW5iaW5kRXZlbnRzIiwiX21hcFBhbmUiLCJjbGFzc05hbWUiLCJyZXBsYWNlIiwiX3NwaWRlcmZpZXJPblJlbW92ZSIsIl9oaWRlQ292ZXJhZ2UiLCJyZW1vdmUiLCJnZXRWaXNpYmxlUGFyZW50Iiwidk1hcmtlciIsIm9iaiIsInNwbGljZSIsIl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkIiwieiIsImdyaWRVbmNsdXN0ZXJlZCIsIm1pblpvb20iLCJmbG9vciIsImdldE1pblpvb20iLCJyZW1vdmVPYmplY3QiLCJwcm9qZWN0IiwiZSIsInRhcmdldCIsIl9fZHJhZ1N0YXJ0IiwiX2lnbm9yZU1vdmUiLCJpc1BvcHVwT3BlbiIsIl9wb3B1cCIsImlzT3BlbiIsIl9tb3ZlQ2hpbGQiLCJvbGRMYXRMbmciLCJvcGVuUG9wdXAiLCJmcm9tIiwidG8iLCJkcmFnU3RhcnQiLCJyZW1vdmVGcm9tRGlzdGFuY2VHcmlkIiwiZG9udFVwZGF0ZU1hcCIsImdyaWRDbHVzdGVycyIsImNsdXN0ZXIiLCJfbWFya2VycyIsIl9jaGlsZENvdW50IiwiX2JvdW5kc05lZWRVcGRhdGUiLCJfY0xhdExuZyIsImFkZE9iamVjdCIsIl9jaGlsZENsdXN0ZXJzIiwiX2ljb25OZWVkc1VwZGF0ZSIsIl9pc09ySXNQYXJlbnQiLCJlbCIsIm9lbCIsInBhcmVudE5vZGUiLCJ0eXBlIiwiZGF0YSIsInByb3BhZ2F0ZSIsIm9yaWdpbmFsRXZlbnQiLCJyZWxhdGVkVGFyZ2V0IiwibGlzdGVucyIsImNoaWxkQ291bnQiLCJjIiwiRGl2SWNvbiIsImh0bWwiLCJpY29uU2l6ZSIsIlBvaW50IiwiX3pvb21PclNwaWRlcmZ5IiwiX3Nob3dDb3ZlcmFnZSIsImJvdHRvbUNsdXN0ZXIiLCJrZXlDb2RlIiwiX2NvbnRhaW5lciIsImZvY3VzIiwiX3Nob3duUG9seWdvbiIsIl9zcGlkZXJmaWVkIiwiUG9seWdvbiIsImdldENvbnZleEh1bGwiLCJfbWVyZ2VTcGxpdENsdXN0ZXJzIiwibmV3Qm91bmRzIiwiX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwIiwibWF4Wm9vbSIsImNlaWwiLCJyYWRpdXMiLCJyYWRpdXNGbiIsInpvb20iLCJEaXN0YW5jZUdyaWQiLCJtYXJrZXJQb2ludCIsIl9vdmVycmlkZU1hcmtlckljb24iLCJjbG9zZXN0IiwiZ2V0TmVhck9iamVjdCIsIl9hZGRDaGlsZCIsInBhcmVudCIsIm5ld0NsdXN0ZXIiLCJsYXN0UGFyZW50IiwiX3VwZGF0ZUljb24iLCJfZW5xdWV1ZSIsImZuIiwiX3F1ZXVlVGltZW91dCIsIl9wcm9jZXNzUXVldWUiLCJjbGVhclRpbWVvdXQiLCJtYXBab29tIiwiaW50ZXJzZWN0cyIsIl9hbmltYXRpb25TdGFydCIsIl9hbmltYXRpb25ab29tSW4iLCJfYW5pbWF0aW9uWm9vbU91dCIsIl9tYXBCb3VuZHNJbmZpbml0ZSIsIkJyb3dzZXIiLCJtb2JpbGUiLCJfY2hlY2tCb3VuZHNNYXhMYXQiLCJwYWQiLCJtYXhMYXQiLCJ1bmRlZmluZWQiLCJnZXROb3J0aCIsIl9ub3J0aEVhc3QiLCJsYXQiLCJJbmZpbml0eSIsImdldFNvdXRoIiwiX3NvdXRoV2VzdCIsIl9hZGRUb01hcCIsImdyb3VwIiwib3V0cHV0IiwiaWNvbiIsImluY2x1ZGUiLCJMYXRMbmciLCJwcmV2aW91c1pvb21MZXZlbCIsIm5ld1pvb21MZXZlbCIsIl9yZWN1cnNpdmVseSIsInN0YXJ0UG9zIiwiX2lzU2luZ2xlUGFyZW50IiwiY2x1c3RlckhpZGUiLCJfZm9yY2VMYXlvdXQiLCJfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlIiwibiIsIl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyIsIl9hbmltYXRpb25FbmQiLCJfYW5pbWF0aW9uWm9vbU91dFNpbmdsZSIsIm1lIiwiX3NldFBvcyIsImxhdExuZ1RvTGF5ZXJQb2ludCIsIl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwIiwic2V0TGF0TG5nIiwiZmFsc2VGbiIsImRvY3VtZW50IiwiYm9keSIsIm9mZnNldFdpZHRoIiwibWFya2VyQ2x1c3Rlckdyb3VwIiwiSWNvbiIsImEiLCJiIiwic3RvcmFnZUFycmF5IiwiaWdub3JlRHJhZ2dlZE1hcmtlciIsImZpdEJvdW5kc09wdGlvbnMiLCJjaGlsZENsdXN0ZXJzIiwiYm91bmRzWm9vbSIsImdldEJvdW5kc1pvb20iLCJnZXRab29tIiwibmV3Q2x1c3RlcnMiLCJjb25jYXQiLCJzZXRWaWV3IiwiZml0Qm91bmRzIiwic2V0SWNvbiIsImNyZWF0ZUljb24iLCJfaWNvbk9iaiIsImNyZWF0ZVNoYWRvdyIsIm5ldzEiLCJpc05vdGlmaWNhdGlvbkZyb21DaGlsZCIsIl9zZXRDbHVzdGVyQ2VudGVyIiwiY2hpbGQiLCJfcmVzZXRCb3VuZHMiLCJsbmciLCJsYXRTdW0iLCJsbmdTdW0iLCJ0b3RhbENvdW50IiwiY2hpbGRMYXRMbmciLCJfd0xhdExuZyIsIl9iYWNrdXBMYXRsbmciLCJfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbiIsImNlbnRlciIsImNtIiwibWFwTWluWm9vbSIsInpvb21MZXZlbCIsIm5tIiwiX3Jlc3RvcmVQb3NpdGlvbiIsImsiLCJwcmV2aW91c0JvdW5kcyIsImV4Y2VwdEJvdW5kcyIsImJvdW5kc1RvQXBwbHlUbyIsInpvb21MZXZlbFRvU3RhcnQiLCJ6b29tTGV2ZWxUb1N0b3AiLCJydW5BdEV2ZXJ5TGV2ZWwiLCJydW5BdEJvdHRvbUxldmVsIiwiYmFja3VwIiwic2V0T3BhY2l0eSIsImNlbGxTaXplIiwiX2NlbGxTaXplIiwiX3NxQ2VsbFNpemUiLCJfZ3JpZCIsIl9vYmplY3RQb2ludCIsInBvaW50IiwieCIsIl9nZXRDb29yZCIsInkiLCJncmlkIiwicm93IiwiY2VsbCIsInVwZGF0ZU9iamVjdCIsImxlbiIsImVhY2hPYmplY3QiLCJyZW1vdmVkIiwiZGlzdCIsIm9iamVjdFBvaW50IiwiY2xvc2VzdERpc3RTcSIsIl9zcURpc3QiLCJjb29yZCIsInAiLCJwMiIsImR4IiwiZHkiLCJRdWlja0h1bGwiLCJnZXREaXN0YW50IiwiY3B0IiwiYmwiLCJ2WSIsInZYIiwiZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmUiLCJiYXNlTGluZSIsImxhdExuZ3MiLCJtYXhEIiwibWF4UHQiLCJuZXdQb2ludHMiLCJwdCIsImQiLCJtYXhQb2ludCIsImJ1aWxkQ29udmV4SHVsbCIsImNvbnZleEh1bGxCYXNlTGluZXMiLCJ0IiwibWluTGF0IiwibWF4TG5nIiwibWluTG5nIiwibWF4TGF0UHQiLCJtaW5MYXRQdCIsIm1heExuZ1B0IiwibWluTG5nUHQiLCJtaW5QdCIsImNoIiwiY2hpbGRNYXJrZXJzIiwicG9pbnRzIiwiXzJQSSIsIlBJIiwiX2NpcmNsZUZvb3RTZXBhcmF0aW9uIiwiX2NpcmNsZVN0YXJ0QW5nbGUiLCJfc3BpcmFsRm9vdFNlcGFyYXRpb24iLCJfc3BpcmFsTGVuZ3RoU3RhcnQiLCJfc3BpcmFsTGVuZ3RoRmFjdG9yIiwiX2NpcmNsZVNwaXJhbFN3aXRjaG92ZXIiLCJwb3NpdGlvbnMiLCJfZ2VuZXJhdGVQb2ludHNTcGlyYWwiLCJfZ2VuZXJhdGVQb2ludHNDaXJjbGUiLCJfYW5pbWF0aW9uU3BpZGVyZnkiLCJ1bnNwaWRlcmZ5Iiwiem9vbURldGFpbHMiLCJfYW5pbWF0aW9uVW5zcGlkZXJmeSIsImNvdW50IiwiY2VudGVyUHQiLCJjaXJjdW1mZXJlbmNlIiwibGVnTGVuZ3RoIiwiYW5nbGVTdGVwIiwicmVzIiwiYW5nbGUiLCJtYXgiLCJjb3MiLCJzaW4iLCJfcm91bmQiLCJzZXBhcmF0aW9uIiwibGVuZ3RoRmFjdG9yIiwiX3ByZVNwaWRlcmZ5TGF0bG5nIiwic2V0WkluZGV4T2Zmc2V0IiwiX3NwaWRlckxlZyIsImxlZ09wdGlvbnMiLCJsZWciLCJuZXdQb3MiLCJsYXllclBvaW50VG9MYXRMbmciLCJQb2x5bGluZSIsInRoaXNMYXllckxhdExuZyIsInRoaXNMYXllclBvcyIsInN2ZyIsIlBhdGgiLCJTVkciLCJmaW5hbExlZ09wYWNpdHkiLCJsZWdQYXRoIiwiX3BhdGgiLCJnZXRUb3RhbExlbmd0aCIsInN0eWxlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInNldFN0eWxlIiwiX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCIsIm5vbkFuaW1hdGFibGUiLCJjbG9zZVBvcHVwIiwic3RpbGxUaGVyZUNoaWxkQ291bnQiLCJhcHBseSIsImFyZ3VtZW50cyIsIl91bnNwaWRlcmZ5V3JhcHBlciIsInpvb21BbmltYXRpb24iLCJfdW5zcGlkZXJmeVpvb21TdGFydCIsInRvdWNoIiwiZ2V0UmVuZGVyZXIiLCJfdW5zcGlkZXJmeVpvb21BbmltIiwiaGFzQ2xhc3MiLCJyZWZyZXNoQ2x1c3RlcnMiLCJfbGF5ZXJzIiwiX2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlIiwiX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyIsInJlZnJlc2hJY29uT3B0aW9ucyIsImRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css":
/*!***************************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css ***!
  \***************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"814dee228a5a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvZGlzdC9NYXJrZXJDbHVzdGVyLkRlZmF1bHQuY3NzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzcz8wZDZlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiODE0ZGVlMjI4YTVhXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.css":
/*!*******************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/MarkerCluster.css ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"e6270cc586ba\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvZGlzdC9NYXJrZXJDbHVzdGVyLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9kaXN0L01hcmtlckNsdXN0ZXIuY3NzPzZiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJlNjI3MGNjNTg2YmFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ZonesDesserviesMap.tsx":
/*!*******************************************!*\
  !*** ./components/ZonesDesserviesMap.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ZonesDesserviesMap; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/hooks.js\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/MapContainer.js\");\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-leaflet */ \"(app-pages-browser)/./node_modules/react-leaflet/lib/TileLayer.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"(app-pages-browser)/./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet_markercluster_dist_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! leaflet.markercluster/dist/MarkerCluster.css */ \"(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.css\");\n/* harmony import */ var leaflet_markercluster_dist_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! leaflet.markercluster/dist/MarkerCluster.Default.css */ \"(app-pages-browser)/./node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css\");\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! leaflet.markercluster */ \"(app-pages-browser)/./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\");\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(leaflet_markercluster__WEBPACK_IMPORTED_MODULE_6__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\n\n\n\n// Liste des centres hospitaliers de Toulouse\nconst hospitalPositions = [\n    {\n        name: \"H\\xf4pital Purpan\",\n        coords: [\n            43.6107,\n            1.4235\n        ]\n    },\n    {\n        name: \"H\\xf4pital Rangueil\",\n        coords: [\n            43.5372,\n            1.4436\n        ]\n    },\n    {\n        name: \"H\\xf4pital Larrey\",\n        coords: [\n            43.5378,\n            1.4451\n        ]\n    },\n    {\n        name: \"H\\xf4pital Pierre-Paul Riquet\",\n        coords: [\n            43.6150,\n            1.4322\n        ]\n    },\n    {\n        name: \"H\\xf4pital des enfants et Paule de Viguier\",\n        coords: [\n            43.5912,\n            1.4573\n        ]\n    },\n    {\n        name: \"H\\xf4pital La Grave - Cit\\xe9 de la sant\\xe9\",\n        coords: [\n            43.6002,\n            1.4445\n        ]\n    },\n    {\n        name: \"Institut Universitaire du Cancer Toulouse-Oncopole\",\n        coords: [\n            43.5471,\n            1.4424\n        ]\n    },\n    {\n        name: \"Centre Hospitalier G\\xe9rard Marchant\",\n        coords: [\n            43.5744,\n            1.4263\n        ]\n    }\n];\n// Icône personnalisée pour les markers\nconst useCustomIcon = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>new (leaflet__WEBPACK_IMPORTED_MODULE_1___default().Icon)({\n            iconUrl: \"/images/logo-marker.png\",\n            iconSize: [\n                40,\n                40\n            ],\n            iconAnchor: [\n                20,\n                40\n            ]\n        }), []);\n};\n_s(useCustomIcon, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n// Ajuste le zoom pour afficher tous les markers\nfunction FitBounds(param) {\n    let { positions } = param;\n    _s1();\n    const map = (0,react_leaflet__WEBPACK_IMPORTED_MODULE_7__.useMap)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (positions.length > 0) {\n            const bounds = leaflet__WEBPACK_IMPORTED_MODULE_1___default().latLngBounds(positions.map((p)=>p.coords));\n            map.fitBounds(bounds, {\n                padding: [\n                    50,\n                    50\n                ]\n            });\n        }\n    }, [\n        map,\n        positions\n    ]);\n    return null;\n}\n_s1(FitBounds, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function() {\n    return [\n        react_leaflet__WEBPACK_IMPORTED_MODULE_7__.useMap\n    ];\n});\n_c = FitBounds;\nfunction ZonesDesserviesMap() {\n    _s2();\n    const customIcon = useCustomIcon();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [positions] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(hospitalPositions);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!mapRef.current) return;\n        const map = mapRef.current;\n        // Crée le cluster\n        const markers = leaflet__WEBPACK_IMPORTED_MODULE_1___default().markerClusterGroup();\n        // Ajoute chaque marker\n        positions.forEach((param)=>{\n            let { coords, name } = param;\n            const marker = leaflet__WEBPACK_IMPORTED_MODULE_1___default().marker(coords, {\n                icon: customIcon\n            });\n            marker.bindPopup(\"<b>\".concat(name, \"</b>\"));\n            markers.addLayer(marker);\n        });\n        map.addLayer(markers);\n        // Ajuste le zoom pour tous les markers\n        map.fitBounds(markers.getBounds(), {\n            padding: [\n                50,\n                50\n            ]\n        });\n    }, [\n        positions,\n        customIcon\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"mt-10\",\n        style: {\n            height: \"400px\",\n            width: \"100%\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_8__.MapContainer, {\n            center: [\n                43.6045,\n                1.4442\n            ],\n            zoom: 10,\n            style: {\n                height: \"100%\",\n                width: \"100%\"\n            },\n            whenCreated: (mapInstance)=>mapRef.current = mapInstance,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_9__.TileLayer, {\n                    url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n                    attribution: '\\xa9 <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n                }, void 0, false, {\n                    fileName: \"/Users/mondz/Downloads/taxi-vsl-nextjs-complete/components/ZonesDesserviesMap.tsx\",\n                    lineNumber: 80,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FitBounds, {\n                    positions: positions\n                }, void 0, false, {\n                    fileName: \"/Users/mondz/Downloads/taxi-vsl-nextjs-complete/components/ZonesDesserviesMap.tsx\",\n                    lineNumber: 84,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/mondz/Downloads/taxi-vsl-nextjs-complete/components/ZonesDesserviesMap.tsx\",\n            lineNumber: 74,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/mondz/Downloads/taxi-vsl-nextjs-complete/components/ZonesDesserviesMap.tsx\",\n        lineNumber: 73,\n        columnNumber: 5\n    }, this);\n}\n_s2(ZonesDesserviesMap, \"NePr4v2HsKe6PUPqGmsczXMkIS0=\", false, function() {\n    return [\n        useCustomIcon\n    ];\n});\n_c1 = ZonesDesserviesMap;\nvar _c, _c1;\n$RefreshReg$(_c, \"FitBounds\");\n$RefreshReg$(_c1, \"ZonesDesserviesMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvWm9uZXNEZXNzZXJ2aWVzTWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRStEO0FBQ3hDO0FBQ3FDO0FBQzNCO0FBQ29CO0FBQ1E7QUFDL0I7QUFFOUIsNkNBQTZDO0FBQzdDLE1BQU1RLG9CQUFvQjtJQUN4QjtRQUFFQyxNQUFNO1FBQWtCQyxRQUFRO1lBQUM7WUFBUztTQUFPO0lBQUM7SUFDcEQ7UUFBRUQsTUFBTTtRQUFvQkMsUUFBUTtZQUFDO1lBQVM7U0FBTztJQUFDO0lBQ3REO1FBQUVELE1BQU07UUFBa0JDLFFBQVE7WUFBQztZQUFTO1NBQU87SUFBQztJQUNwRDtRQUFFRCxNQUFNO1FBQThCQyxRQUFRO1lBQUM7WUFBUztTQUFPO0lBQUM7SUFDaEU7UUFBRUQsTUFBTTtRQUEyQ0MsUUFBUTtZQUFDO1lBQVM7U0FBTztJQUFDO0lBQzdFO1FBQUVELE1BQU07UUFBdUNDLFFBQVE7WUFBQztZQUFTO1NBQU87SUFBQztJQUN6RTtRQUFFRCxNQUFNO1FBQXNEQyxRQUFRO1lBQUM7WUFBUztTQUFPO0lBQUM7SUFDeEY7UUFBRUQsTUFBTTtRQUFzQ0MsUUFBUTtZQUFDO1lBQVM7U0FBTztJQUFDO0NBQ3pFO0FBRUQsdUNBQXVDO0FBQ3ZDLE1BQU1DLGdCQUFnQjs7SUFDcEJOLE9BQUFBLDhDQUFPQSxDQUNMLElBQ0UsSUFBSUYscURBQU0sQ0FBQztZQUNUVSxTQUFTO1lBQ1RDLFVBQVU7Z0JBQUM7Z0JBQUk7YUFBRztZQUNsQkMsWUFBWTtnQkFBQztnQkFBSTthQUFHO1FBQ3RCLElBQ0YsRUFBRTtBQUNKO0dBVElKO0FBV04sZ0RBQWdEO0FBQ2hELFNBQVNLLFVBQVUsS0FBYTtRQUFiLEVBQUVDLFNBQVMsRUFBRSxHQUFiOztJQUNqQixNQUFNQyxNQUFNaEIscURBQU1BO0lBQ2xCRSxnREFBU0EsQ0FBQztRQUNSLElBQUlhLFVBQVVFLE1BQU0sR0FBRyxHQUFHO1lBQ3hCLE1BQU1DLFNBQVNqQiwyREFBYyxDQUFDYyxVQUFVQyxHQUFHLENBQUNJLENBQUFBLElBQUtBLEVBQUVaLE1BQU07WUFDekRRLElBQUlLLFNBQVMsQ0FBQ0gsUUFBUTtnQkFBRUksU0FBUztvQkFBQztvQkFBSTtpQkFBRztZQUFDO1FBQzVDO0lBQ0YsR0FBRztRQUFDTjtRQUFLRDtLQUFVO0lBQ25CLE9BQU87QUFDVDtJQVRTRDs7UUFDS2QsaURBQU1BOzs7S0FEWGM7QUFXTSxTQUFTUzs7SUFDdEIsTUFBTUMsYUFBYWY7SUFDbkIsTUFBTWdCLFNBQVNyQiw2Q0FBTUEsQ0FBQztJQUN0QixNQUFNLENBQUNXLFVBQVUsR0FBR1YsK0NBQVFBLENBQUNDO0lBRTdCSixnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ3VCLE9BQU9DLE9BQU8sRUFBRTtRQUNyQixNQUFNVixNQUFNUyxPQUFPQyxPQUFPO1FBRTFCLGtCQUFrQjtRQUNsQixNQUFNQyxVQUFVMUIsaUVBQW9CO1FBRXBDLHVCQUF1QjtRQUN2QmMsVUFBVWMsT0FBTyxDQUFDO2dCQUFDLEVBQUVyQixNQUFNLEVBQUVELElBQUksRUFBRTtZQUNqQyxNQUFNdUIsU0FBUzdCLHFEQUFRLENBQUNPLFFBQVE7Z0JBQUV1QixNQUFNUDtZQUFXO1lBQ25ETSxPQUFPRSxTQUFTLENBQUMsTUFBVyxPQUFMekIsTUFBSztZQUM1Qm9CLFFBQVFNLFFBQVEsQ0FBQ0g7UUFDbkI7UUFFQWQsSUFBSWlCLFFBQVEsQ0FBQ047UUFFYix1Q0FBdUM7UUFDdkNYLElBQUlLLFNBQVMsQ0FBQ00sUUFBUU8sU0FBUyxJQUFJO1lBQUVaLFNBQVM7Z0JBQUM7Z0JBQUk7YUFBRztRQUFDO0lBQ3pELEdBQUc7UUFBQ1A7UUFBV1M7S0FBVztJQUUxQixxQkFDRSw4REFBQ1c7UUFBSUMsV0FBVTtRQUFRQyxPQUFPO1lBQUVDLFFBQVE7WUFBU0MsT0FBTztRQUFPO2tCQUM3RCw0RUFBQ3pDLHVEQUFZQTtZQUNYMEMsUUFBUTtnQkFBQztnQkFBUzthQUFPO1lBQ3pCQyxNQUFNO1lBQ05KLE9BQU87Z0JBQUVDLFFBQVE7Z0JBQVFDLE9BQU87WUFBTztZQUN2Q0csYUFBYSxDQUFDQyxjQUFpQmxCLE9BQU9DLE9BQU8sR0FBR2lCOzs4QkFFaEQsOERBQUM1QyxvREFBU0E7b0JBQ1I2QyxLQUFJO29CQUNKQyxhQUFZOzs7Ozs7OEJBRWQsOERBQUMvQjtvQkFBVUMsV0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSTlCO0lBekN3QlE7O1FBQ0hkOzs7TUFER2MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9ab25lc0Rlc3NlcnZpZXNNYXAudHN4PzUwNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgTWFwQ29udGFpbmVyLCBUaWxlTGF5ZXIsIHVzZU1hcCB9IGZyb20gXCJyZWFjdC1sZWFmbGV0XCJcbmltcG9ydCBMIGZyb20gXCJsZWFmbGV0XCJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgXCJsZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3NcIlxuaW1wb3J0IFwibGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvTWFya2VyQ2x1c3Rlci5jc3NcIlxuaW1wb3J0IFwibGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzc1wiXG5pbXBvcnQgXCJsZWFmbGV0Lm1hcmtlcmNsdXN0ZXJcIlxuXG4vLyBMaXN0ZSBkZXMgY2VudHJlcyBob3NwaXRhbGllcnMgZGUgVG91bG91c2VcbmNvbnN0IGhvc3BpdGFsUG9zaXRpb25zID0gW1xuICB7IG5hbWU6IFwiSMO0cGl0YWwgUHVycGFuXCIsIGNvb3JkczogWzQzLjYxMDcsIDEuNDIzNV0gfSxcbiAgeyBuYW1lOiBcIkjDtHBpdGFsIFJhbmd1ZWlsXCIsIGNvb3JkczogWzQzLjUzNzIsIDEuNDQzNl0gfSxcbiAgeyBuYW1lOiBcIkjDtHBpdGFsIExhcnJleVwiLCBjb29yZHM6IFs0My41Mzc4LCAxLjQ0NTFdIH0sXG4gIHsgbmFtZTogXCJIw7RwaXRhbCBQaWVycmUtUGF1bCBSaXF1ZXRcIiwgY29vcmRzOiBbNDMuNjE1MCwgMS40MzIyXSB9LFxuICB7IG5hbWU6IFwiSMO0cGl0YWwgZGVzIGVuZmFudHMgZXQgUGF1bGUgZGUgVmlndWllclwiLCBjb29yZHM6IFs0My41OTEyLCAxLjQ1NzNdIH0sXG4gIHsgbmFtZTogXCJIw7RwaXRhbCBMYSBHcmF2ZSAtIENpdMOpIGRlIGxhIHNhbnTDqVwiLCBjb29yZHM6IFs0My42MDAyLCAxLjQ0NDVdIH0sXG4gIHsgbmFtZTogXCJJbnN0aXR1dCBVbml2ZXJzaXRhaXJlIGR1IENhbmNlciBUb3Vsb3VzZS1PbmNvcG9sZVwiLCBjb29yZHM6IFs0My41NDcxLCAxLjQ0MjRdIH0sXG4gIHsgbmFtZTogXCJDZW50cmUgSG9zcGl0YWxpZXIgR8OpcmFyZCBNYXJjaGFudFwiLCBjb29yZHM6IFs0My41NzQ0LCAxLjQyNjNdIH0sXG5dXG5cbi8vIEljw7RuZSBwZXJzb25uYWxpc8OpZSBwb3VyIGxlcyBtYXJrZXJzXG5jb25zdCB1c2VDdXN0b21JY29uID0gKCkgPT5cbiAgdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgbmV3IEwuSWNvbih7XG4gICAgICAgIGljb25Vcmw6IFwiL2ltYWdlcy9sb2dvLW1hcmtlci5wbmdcIiwgLy8gY2hlbWluIGRhbnMgL3B1YmxpYy9pbWFnZXMvXG4gICAgICAgIGljb25TaXplOiBbNDAsIDQwXSxcbiAgICAgICAgaWNvbkFuY2hvcjogWzIwLCA0MF0sXG4gICAgICB9KSxcbiAgICBbXVxuICApXG5cbi8vIEFqdXN0ZSBsZSB6b29tIHBvdXIgYWZmaWNoZXIgdG91cyBsZXMgbWFya2Vyc1xuZnVuY3Rpb24gRml0Qm91bmRzKHsgcG9zaXRpb25zIH0pIHtcbiAgY29uc3QgbWFwID0gdXNlTWFwKClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHBvc2l0aW9ucy5tYXAocCA9PiBwLmNvb3JkcykpXG4gICAgICBtYXAuZml0Qm91bmRzKGJvdW5kcywgeyBwYWRkaW5nOiBbNTAsIDUwXSB9KVxuICAgIH1cbiAgfSwgW21hcCwgcG9zaXRpb25zXSlcbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWm9uZXNEZXNzZXJ2aWVzTWFwKCkge1xuICBjb25zdCBjdXN0b21JY29uID0gdXNlQ3VzdG9tSWNvbigpXG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZihudWxsKVxuICBjb25zdCBbcG9zaXRpb25zXSA9IHVzZVN0YXRlKGhvc3BpdGFsUG9zaXRpb25zKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgY29uc3QgbWFwID0gbWFwUmVmLmN1cnJlbnRcblxuICAgIC8vIENyw6llIGxlIGNsdXN0ZXJcbiAgICBjb25zdCBtYXJrZXJzID0gTC5tYXJrZXJDbHVzdGVyR3JvdXAoKVxuXG4gICAgLy8gQWpvdXRlIGNoYXF1ZSBtYXJrZXJcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgoeyBjb29yZHMsIG5hbWUgfSkgPT4ge1xuICAgICAgY29uc3QgbWFya2VyID0gTC5tYXJrZXIoY29vcmRzLCB7IGljb246IGN1c3RvbUljb24gfSlcbiAgICAgIG1hcmtlci5iaW5kUG9wdXAoYDxiPiR7bmFtZX08L2I+YClcbiAgICAgIG1hcmtlcnMuYWRkTGF5ZXIobWFya2VyKVxuICAgIH0pXG5cbiAgICBtYXAuYWRkTGF5ZXIobWFya2VycylcblxuICAgIC8vIEFqdXN0ZSBsZSB6b29tIHBvdXIgdG91cyBsZXMgbWFya2Vyc1xuICAgIG1hcC5maXRCb3VuZHMobWFya2Vycy5nZXRCb3VuZHMoKSwgeyBwYWRkaW5nOiBbNTAsIDUwXSB9KVxuICB9LCBbcG9zaXRpb25zLCBjdXN0b21JY29uXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMTBcIiBzdHlsZT17eyBoZWlnaHQ6IFwiNDAwcHhcIiwgd2lkdGg6IFwiMTAwJVwiIH19PlxuICAgICAgPE1hcENvbnRhaW5lclxuICAgICAgICBjZW50ZXI9e1s0My42MDQ1LCAxLjQ0NDJdfVxuICAgICAgICB6b29tPXsxMH1cbiAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiBcIjEwMCVcIiwgd2lkdGg6IFwiMTAwJVwiIH19XG4gICAgICAgIHdoZW5DcmVhdGVkPXsobWFwSW5zdGFuY2UpID0+IChtYXBSZWYuY3VycmVudCA9IG1hcEluc3RhbmNlKX1cbiAgICAgID5cbiAgICAgICAgPFRpbGVMYXllclxuICAgICAgICAgIHVybD1cImh0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nXCJcbiAgICAgICAgICBhdHRyaWJ1dGlvbj0nJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnXG4gICAgICAgIC8+XG4gICAgICAgIDxGaXRCb3VuZHMgcG9zaXRpb25zPXtwb3NpdGlvbnN9IC8+XG4gICAgICA8L01hcENvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIk1hcENvbnRhaW5lciIsIlRpbGVMYXllciIsInVzZU1hcCIsIkwiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJob3NwaXRhbFBvc2l0aW9ucyIsIm5hbWUiLCJjb29yZHMiLCJ1c2VDdXN0b21JY29uIiwiSWNvbiIsImljb25VcmwiLCJpY29uU2l6ZSIsImljb25BbmNob3IiLCJGaXRCb3VuZHMiLCJwb3NpdGlvbnMiLCJtYXAiLCJsZW5ndGgiLCJib3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJwIiwiZml0Qm91bmRzIiwicGFkZGluZyIsIlpvbmVzRGVzc2Vydmllc01hcCIsImN1c3RvbUljb24iLCJtYXBSZWYiLCJjdXJyZW50IiwibWFya2VycyIsIm1hcmtlckNsdXN0ZXJHcm91cCIsImZvckVhY2giLCJtYXJrZXIiLCJpY29uIiwiYmluZFBvcHVwIiwiYWRkTGF5ZXIiLCJnZXRCb3VuZHMiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwiY2VudGVyIiwiem9vbSIsIndoZW5DcmVhdGVkIiwibWFwSW5zdGFuY2UiLCJ1cmwiLCJhdHRyaWJ1dGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ZonesDesserviesMap.tsx\n"));

/***/ })

});